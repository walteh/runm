//go:build darwin

// SPDX-FileCopyrightText: The vmnet-helper authors
// SPDX-License-Identifier: Apache-2.0

// package vment provides the helper process connecting virtual machines to the
// vmnet network.
package vmnet

import (
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"syscall"
)

const (
	helperPidfile    = "vment-helper.pid"
	helperExecutable = "/opt/vmnet-helper/bin/vmnet-helper"
)

type OperationMode string

const (
	// OperationModeShared Allows traffic originating from the vmnet interface
	// to reach the Internet through a network address translator (NAT). The
	// vmnet interface can also communicate with the native host. By default,
	// the vmnet interface is able to communicate with other shared mode
	// interfaces. If a subnet range is specified, the vmnet interface can
	// communicate with other shared mode interfaces on the same subnet.
	OperationModeShared = OperationMode("shared")

	// OperationModeBridged Bridges the vmnet interface with a physical network
	// interface. In the call to vmnet_start_interface(), the interface_desc
	// dictionary must contain the vmnet_shared_interface_name_key property
	// specifying the name of the physical interface.
	OperationModeBridged = OperationMode("bridged")

	// OperationModeHost allows the vmnet interface to communicate with other
	// vmnet interfaces that are in host mode and also with the native host.
	OperationModeHost = OperationMode("host")
)

// HelperOptions are vment-helper options.
type HelperOptions struct {
	// A connected unix datagram socket to pass the helper child process. One of
	// Fd or Socekt is required.
	Fd *os.File

	// Socket is a unix datagram socket path. If specified, the helper creates
	// the sockets and wait for client connection. One of Fd or Socekt is required.
	Socket string

	// Pidfile is the path to write the helper pid. If not set pidfile is not
	// created.
	Pidfile string

	// Logfile is an open file for writing helper logs. If not set, helper logs are
	// discarded.
	Logfile *os.File

	// Verbose enables more verbose logs.
	Verbose bool

	// InterfaceID is and identifier (uuid) to uniquely identify the specific
	// interface instance. The MAC address is assigned by the vmnet framework
	// based on the interface ID. If not set, new interface ID is generated by
	// the vmnet framework.
	InterfaceID string

	// OperationMode is vment interface operation mode. Default to
	// OperationModeShared.
	OperationMode OperationMode

	// StartAddress The starting IPv4 address (string) to use for the interface.
	// This address is used as the gateway address. The subsequent address up to
	// and including EndAddress are placed in the DHCP pool. All other addresses
	// are available for static assignment. The address must be in the private
	// IP range (RFC 1918). Default to "192.168.105.1".
	StartAddress string

	// EndAddress is the DHCP IPv4 range end address (string) to use for the
	// interface. The address must be in the private IP range (RFC 1918).
	// Default to "192.168.105.254".
	EndAddress string

	// SubnetMask is the IPv4 subnet mask (string) to use on the interface.
	// Default to "255.255.255.0".
	SubnetMask string

	// SharedInterface is the name of the interface (string) to use when the
	// operating mode of the interface is OperationModeBridged. Required if
	// using OperationModeBridged.
	SharedInterface string

	// EnableIsolation enable isolation for this interface. Interface isolation
	// ensures that network communication between multiple vmnet interface
	// instances is not possible. Used only for OperationModeHost.
	EnableIsolation bool
}

// InterfaceInfo describes the vmnet interface created when starting the helper.
type InterfaceInfo struct {
	SubnetMask    string `json:"vmnet_subnet_mask"`
	MTU           uint   `json:"vmnet_mtu"`
	EndAddress    string `json:"vmnet_end_address"`
	StartAddress  string `json:"vmnet_start_address"`
	InterfaceID   string `json:"vmnet_interface_id"`
	MaxPacketSize uint   `json:"vmnet_max_packet_size"`
	NAT66Prefix   string `json:"vmnet_nat66_prefix"`
	MACAddress    string `json:"vmnet_mac_address"`
}

// Helper is vment-helper process connecting virtual machines to the vmnet network.
type Helper struct {
	options       *HelperOptions
	cmd           *exec.Cmd
	interfaceInfo *InterfaceInfo
}

// HelperAvailable tells if vment-helper executable is installed.
func HelperAvailable() bool {
	if _, err := os.Stat(helperExecutable); err == nil {
		return true
	}
	return false
}

// Validate returns an error if options are invalid.
func (o *HelperOptions) Validate() error {
	// XXX
	// - fd or socket are set
	// - operation mode valid
	// - bridged: shared interface is set
	return nil
}

// NewHelper create a new helper.
func NewHelper(options HelperOptions) *Helper {
	return &Helper{options: &options}
}

// Start start the vmnet-helper child process, creating the vmnet interface.
func (h *Helper) Start() error {
	if err := h.options.Validate(); err != nil {
		return fmt.Errorf("invalid helper options: %w", err)
	}

	args := []string{"--non-interactive"}
	if h.options.Fd != nil {
		args = append(args,
			"--close-from", fmt.Sprintf("%d", h.options.Fd.Fd()+1),
			helperExecutable,
			"--fd", fmt.Sprintf("%d", h.options.Fd.Fd()),
		)
	} else if h.options.Socket != "" {
		args = append(args, helperExecutable, "--socket", h.options.Socket)
	} else {
		panic("Fd and Socket unset")
	}

	if h.options.InterfaceID != "" {
		args = append(args, "--interface-id", h.options.InterfaceID)
	}
	if h.options.Pidfile != "" {
		// XXX not implemented yet in the helper
		args = append(args, "--pidfile", h.options.Pidfile)
	}
	if h.options.Verbose {
		args = append(args, "--verbose")
	}

	// XXX add rest of optional options

	h.cmd = exec.Command("sudo", args...)

	if h.options.Fd != nil {
		h.cmd.ExtraFiles = []*os.File{h.options.Fd}
	}

	// Create vment-helper in a new process group so it is not harmed when
	// terminating the process group.
	h.cmd.SysProcAttr = &syscall.SysProcAttr{Setpgid: true}

	h.cmd.Stderr = h.options.Logfile

	stdout, err := h.cmd.StdoutPipe()
	if err != nil {
		return fmt.Errorf("failed to create helper stdout pipe: %w", err)
	}

	if err := h.cmd.Start(); err != nil {
		return fmt.Errorf("failed to start helper: %w", err)
	}

	var info InterfaceInfo
	if err := json.NewDecoder(stdout).Decode(&info); err != nil {
		return fmt.Errorf("failed to decode helper interface info: %w", err)
	}

	h.interfaceInfo = &info

	return nil
}

// InterfaceInfo return information about the vmnet interface. Return nil if the
// vmnet interface was not started.
func (h *Helper) InterfaceInfo() *InterfaceInfo {
	return h.interfaceInfo
}

// Stop terminates the helper child process.
func (h *Helper) Stop() error {
	if err := h.cmd.Process.Signal(syscall.SIGTERM); err != nil {
		if err != os.ErrProcessDone {
			return fmt.Errorf("failed to signal helper: %w", err)
		}
	}
	if err := h.cmd.Wait(); err != nil {
		return fmt.Errorf("helper failed: %w", err)
	}
	return nil
}

// Apple recommend receive buffer size to be 4 times the size of the send buffer
// size, but send buffer size is not used to allocate a buffer in datagram
// sockets, it only limits the maximum packet size. Must be larger than TSO
// packets size (65550 bytes).
const sendBufferSize = 65 * 1024

// The receive buffer size determine how many packets can be queued by the
// peer. Using bigger receive buffer size make ENOBUFS error less likely for the
// peer and improves throughput.
const recvBufferSize = 4 * 1024 * 1024

// Socketpair returns a pair of connected unix datagram sockets that can be used
// to connect the helper and a vm. Pass one socket to the helper child process
// and the other to the vm child process.
func Socketpair() (*os.File, *os.File, error) {
	fds, err := syscall.Socketpair(syscall.AF_UNIX, syscall.SOCK_DGRAM, 0)
	if err != nil {
		return nil, nil, err
	}
	// Setting buffer size is an optimization - don't fail on errors.
	for _, fd := range fds {
		_ = syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, sendBufferSize)
		_ = syscall.SetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, recvBufferSize)
	}
	return os.NewFile(uintptr(fds[0]), "sock1"), os.NewFile(uintptr(fds[1]), "sock2"), nil
}

// UUIDFromName generated a random UUID (type 4) from string name. This is
// useful for creating interface ID from virtual machine name to ensure the same
// MAC address in all runs.
func UUIDFromName(name string) string {
	sum := sha256.Sum256([]byte(name))
	uuid := sum[:16]
	uuid[6] = (uuid[6] & 0x0f) | 0x40 // Version 4
	uuid[8] = (uuid[8] & 0x3f) | 0x80 // Variant is 10
	return fmt.Sprintf("%4x-%2x-%2x-%2x-%6x", uuid[0:4], uuid[4:6], uuid[6:8], uuid[8:10], uuid[10:16])
}
