// Code generated by protoc-gen-go-ttrpc. DO NOT EDIT.
// source: v1/socket.proto
package runvv1

import (
	context "context"
	ttrpc "github.com/containerd/ttrpc"
)

type TTRPCSocketAllocatorServiceService interface {
	AllocateSockets(context.Context, *AllocateSocketsRequest) (*AllocateSocketsResponse, error)
	AllocateSocketStream(context.Context, *AllocateSocketStreamRequest, TTRPCSocketAllocatorService_AllocateSocketStreamServer) error
	AllocateIO(context.Context, *AllocateIORequest) (*AllocateIOResponse, error)
	AllocateConsole(context.Context, *AllocateConsoleRequest) (*AllocateConsoleResponse, error)
	BindConsoleToSocket(context.Context, *BindConsoleToSocketRequest) (*BindConsoleToSocketResponse, error)
	BindIOToSockets(context.Context, *BindIOToSocketsRequest) (*BindIOToSocketsResponse, error)
	CloseSocket(context.Context, *CloseSocketRequest) (*CloseSocketResponse, error)
	CloseSockets(context.Context, *CloseSocketsRequest) (*CloseSocketsResponse, error)
	CloseIO(context.Context, *CloseIORequest) (*CloseIOResponse, error)
	CloseConsole(context.Context, *CloseConsoleRequest) (*CloseConsoleResponse, error)
}

type TTRPCSocketAllocatorService_AllocateSocketStreamServer interface {
	Send(*AllocateSocketStreamResponse) error
	ttrpc.StreamServer
}

type ttrpcsocketallocatorserviceAllocateSocketStreamServer struct {
	ttrpc.StreamServer
}

func (x *ttrpcsocketallocatorserviceAllocateSocketStreamServer) Send(m *AllocateSocketStreamResponse) error {
	return x.StreamServer.SendMsg(m)
}

func RegisterTTRPCSocketAllocatorServiceService(srv *ttrpc.Server, svc TTRPCSocketAllocatorServiceService) {
	srv.RegisterService("runv.v1.SocketAllocatorService", &ttrpc.ServiceDesc{
		Methods: map[string]ttrpc.Method{
			"AllocateSockets": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req AllocateSocketsRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.AllocateSockets(ctx, &req)
			},
			"AllocateIO": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req AllocateIORequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.AllocateIO(ctx, &req)
			},
			"AllocateConsole": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req AllocateConsoleRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.AllocateConsole(ctx, &req)
			},
			"BindConsoleToSocket": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req BindConsoleToSocketRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.BindConsoleToSocket(ctx, &req)
			},
			"BindIOToSockets": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req BindIOToSocketsRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.BindIOToSockets(ctx, &req)
			},
			"CloseSocket": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req CloseSocketRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.CloseSocket(ctx, &req)
			},
			"CloseSockets": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req CloseSocketsRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.CloseSockets(ctx, &req)
			},
			"CloseIO": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req CloseIORequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.CloseIO(ctx, &req)
			},
			"CloseConsole": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req CloseConsoleRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.CloseConsole(ctx, &req)
			},
		},
		Streams: map[string]ttrpc.Stream{
			"AllocateSocketStream": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					m := new(AllocateSocketStreamRequest)
					if err := stream.RecvMsg(m); err != nil {
						return nil, err
					}
					return nil, svc.AllocateSocketStream(ctx, m, &ttrpcsocketallocatorserviceAllocateSocketStreamServer{stream})
				},
				StreamingClient: false,
				StreamingServer: true,
			},
		},
	})
}

type TTRPCSocketAllocatorServiceClient interface {
	AllocateSockets(context.Context, *AllocateSocketsRequest) (*AllocateSocketsResponse, error)
	AllocateSocketStream(context.Context, *AllocateSocketStreamRequest) (TTRPCSocketAllocatorService_AllocateSocketStreamClient, error)
	AllocateIO(context.Context, *AllocateIORequest) (*AllocateIOResponse, error)
	AllocateConsole(context.Context, *AllocateConsoleRequest) (*AllocateConsoleResponse, error)
	BindConsoleToSocket(context.Context, *BindConsoleToSocketRequest) (*BindConsoleToSocketResponse, error)
	BindIOToSockets(context.Context, *BindIOToSocketsRequest) (*BindIOToSocketsResponse, error)
	CloseSocket(context.Context, *CloseSocketRequest) (*CloseSocketResponse, error)
	CloseSockets(context.Context, *CloseSocketsRequest) (*CloseSocketsResponse, error)
	CloseIO(context.Context, *CloseIORequest) (*CloseIOResponse, error)
	CloseConsole(context.Context, *CloseConsoleRequest) (*CloseConsoleResponse, error)
}

type ttrpcsocketallocatorserviceClient struct {
	client *ttrpc.Client
}

func NewTTRPCSocketAllocatorServiceClient(client *ttrpc.Client) TTRPCSocketAllocatorServiceClient {
	return &ttrpcsocketallocatorserviceClient{
		client: client,
	}
}

func (c *ttrpcsocketallocatorserviceClient) AllocateSockets(ctx context.Context, req *AllocateSocketsRequest) (*AllocateSocketsResponse, error) {
	var resp AllocateSocketsResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "AllocateSockets", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) AllocateSocketStream(ctx context.Context, req *AllocateSocketStreamRequest) (TTRPCSocketAllocatorService_AllocateSocketStreamClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: false,
		StreamingServer: true,
	}, "runv.v1.SocketAllocatorService", "AllocateSocketStream", req)
	if err != nil {
		return nil, err
	}
	x := &ttrpcsocketallocatorserviceAllocateSocketStreamClient{stream}
	return x, nil
}

type TTRPCSocketAllocatorService_AllocateSocketStreamClient interface {
	Recv() (*AllocateSocketStreamResponse, error)
	ttrpc.ClientStream
}

type ttrpcsocketallocatorserviceAllocateSocketStreamClient struct {
	ttrpc.ClientStream
}

func (x *ttrpcsocketallocatorserviceAllocateSocketStreamClient) Recv() (*AllocateSocketStreamResponse, error) {
	m := new(AllocateSocketStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ttrpcsocketallocatorserviceClient) AllocateIO(ctx context.Context, req *AllocateIORequest) (*AllocateIOResponse, error) {
	var resp AllocateIOResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "AllocateIO", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) AllocateConsole(ctx context.Context, req *AllocateConsoleRequest) (*AllocateConsoleResponse, error) {
	var resp AllocateConsoleResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "AllocateConsole", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) BindConsoleToSocket(ctx context.Context, req *BindConsoleToSocketRequest) (*BindConsoleToSocketResponse, error) {
	var resp BindConsoleToSocketResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "BindConsoleToSocket", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) BindIOToSockets(ctx context.Context, req *BindIOToSocketsRequest) (*BindIOToSocketsResponse, error) {
	var resp BindIOToSocketsResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "BindIOToSockets", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) CloseSocket(ctx context.Context, req *CloseSocketRequest) (*CloseSocketResponse, error) {
	var resp CloseSocketResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "CloseSocket", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) CloseSockets(ctx context.Context, req *CloseSocketsRequest) (*CloseSocketsResponse, error) {
	var resp CloseSocketsResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "CloseSockets", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) CloseIO(ctx context.Context, req *CloseIORequest) (*CloseIOResponse, error) {
	var resp CloseIOResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "CloseIO", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) CloseConsole(ctx context.Context, req *CloseConsoleRequest) (*CloseConsoleResponse, error) {
	var resp CloseConsoleResponse
	if err := c.client.Call(ctx, "runv.v1.SocketAllocatorService", "CloseConsole", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}
