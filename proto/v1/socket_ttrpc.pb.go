// Code generated by protoc-gen-go-ttrpc. DO NOT EDIT.
// source: v1/socket.proto
package runmv1

import (
	context "context"
	ttrpc "github.com/containerd/ttrpc"
)

type TTRPCSocketAllocatorServiceService interface {
	DialOpenListener(context.Context, *DialOpenListenerRequest) (*DialOpenListenerResponse, error)
	AllocateIO(context.Context, *AllocateIORequest) (*AllocateIOResponse, error)
	AllocateConsole(context.Context, *AllocateConsoleRequest) (*AllocateConsoleResponse, error)
	BindConsoleToSocket(context.Context, *BindConsoleToSocketRequest) (*BindConsoleToSocketResponse, error)
	BindIOToSockets(context.Context, *BindIOToSocketsRequest) (*BindIOToSocketsResponse, error)
	CloseSocket(context.Context, *CloseSocketRequest) (*CloseSocketResponse, error)
	CloseSockets(context.Context, *CloseSocketsRequest) (*CloseSocketsResponse, error)
	CloseIO(context.Context, *CloseIORequest) (*CloseIOResponse, error)
	CloseConsole(context.Context, *CloseConsoleRequest) (*CloseConsoleResponse, error)
}

func RegisterTTRPCSocketAllocatorServiceService(srv *ttrpc.Server, svc TTRPCSocketAllocatorServiceService) {
	srv.RegisterService("runm.v1.SocketAllocatorService", &ttrpc.ServiceDesc{
		Methods: map[string]ttrpc.Method{
			"DialOpenListener": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req DialOpenListenerRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.DialOpenListener(ctx, &req)
			},
			"AllocateIO": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req AllocateIORequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.AllocateIO(ctx, &req)
			},
			"AllocateConsole": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req AllocateConsoleRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.AllocateConsole(ctx, &req)
			},
			"BindConsoleToSocket": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req BindConsoleToSocketRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.BindConsoleToSocket(ctx, &req)
			},
			"BindIOToSockets": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req BindIOToSocketsRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.BindIOToSockets(ctx, &req)
			},
			"CloseSocket": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req CloseSocketRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.CloseSocket(ctx, &req)
			},
			"CloseSockets": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req CloseSocketsRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.CloseSockets(ctx, &req)
			},
			"CloseIO": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req CloseIORequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.CloseIO(ctx, &req)
			},
			"CloseConsole": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req CloseConsoleRequest
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.CloseConsole(ctx, &req)
			},
		},
	})
}

type ttrpcsocketallocatorserviceClient struct {
	client *ttrpc.Client
}

func NewTTRPCSocketAllocatorServiceClient(client *ttrpc.Client) TTRPCSocketAllocatorServiceService {
	return &ttrpcsocketallocatorserviceClient{
		client: client,
	}
}

func (c *ttrpcsocketallocatorserviceClient) DialOpenListener(ctx context.Context, req *DialOpenListenerRequest) (*DialOpenListenerResponse, error) {
	var resp DialOpenListenerResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "DialOpenListener", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) AllocateIO(ctx context.Context, req *AllocateIORequest) (*AllocateIOResponse, error) {
	var resp AllocateIOResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "AllocateIO", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) AllocateConsole(ctx context.Context, req *AllocateConsoleRequest) (*AllocateConsoleResponse, error) {
	var resp AllocateConsoleResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "AllocateConsole", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) BindConsoleToSocket(ctx context.Context, req *BindConsoleToSocketRequest) (*BindConsoleToSocketResponse, error) {
	var resp BindConsoleToSocketResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "BindConsoleToSocket", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) BindIOToSockets(ctx context.Context, req *BindIOToSocketsRequest) (*BindIOToSocketsResponse, error) {
	var resp BindIOToSocketsResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "BindIOToSockets", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) CloseSocket(ctx context.Context, req *CloseSocketRequest) (*CloseSocketResponse, error) {
	var resp CloseSocketResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "CloseSocket", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) CloseSockets(ctx context.Context, req *CloseSocketsRequest) (*CloseSocketsResponse, error) {
	var resp CloseSocketsResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "CloseSockets", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) CloseIO(ctx context.Context, req *CloseIORequest) (*CloseIOResponse, error) {
	var resp CloseIOResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "CloseIO", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *ttrpcsocketallocatorserviceClient) CloseConsole(ctx context.Context, req *CloseConsoleRequest) (*CloseConsoleResponse, error) {
	var resp CloseConsoleResponse
	if err := c.client.Call(ctx, "runm.v1.SocketAllocatorService", "CloseConsole", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}
