// Code generated by protoc-gen-slog-valuer. DO NOT EDIT.
//
// source: v1/runc.proto

package runmv1

import (
	fmt "fmt"
	slog "log/slog"
)

func (x *RuncReadPidFileRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("path", x.GetPath()))
	return slog.GroupValue(attrs...)
}

func (x *RuncReadPidFileResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Int64("pid", int64(x.GetPid())))
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncNewTempConsoleSocketRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncNewTempConsoleSocketResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("console_reference_id", x.GetConsoleReferenceId()))
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCloseIORequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Uint64("io_reference_id", x.GetIoReferenceId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCloseIOResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncLogFilePathRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncLogFilePathResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("path", x.GetPath()))
	return slog.GroupValue(attrs...)
}

func (x *PingRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *PingResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncListRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("root", x.GetRoot()))
	return slog.GroupValue(attrs...)
}

func (x *RuncContainer) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 7)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.Int64("pid", int64(x.GetPid())))
	attrs = append(attrs, slog.String("status", x.GetStatus()))
	attrs = append(attrs, slog.String("bundle", x.GetBundle()))
	attrs = append(attrs, slog.String("rootfs", x.GetRootfs()))
	attrs = append(attrs, slog.Int64("created_timestamp", x.GetCreatedTimestamp()))
	if len(x.GetAnnotations()) != 0 {
		attrs6 := make([]slog.Attr, 0, len(x.GetAnnotations()))
		for k, v := range x.GetAnnotations() {
			attrs6 = append(attrs6, slog.String(fmt.Sprintf("%v", k), v))
		}
		attrs = append(attrs, slog.Any("annotations", attrs6))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncListResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if len(x.GetContainers()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetContainers()))
		for i, v := range x.GetContainers() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs0 = append(attrs0, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs0 = append(attrs0, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("containers", attrs0))
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStateRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStateResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if x.GetContainer() != nil {
		if v, ok := interface{}(x.GetContainer()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "container", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("container", x.GetContainer()))
		}
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCreateRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.String("bundle", x.GetBundle()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncCreateOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 8)
	attrs = append(attrs, slog.Bool("detach", x.GetDetach()))
	attrs = append(attrs, slog.Bool("no_pivot", x.GetNoPivot()))
	attrs = append(attrs, slog.Bool("no_new_keyring", x.GetNoNewKeyring()))
	attrs = append(attrs, slog.String("pid_file", x.GetPidFile()))
	if len(x.GetExtraArgs()) != 0 {
		attrs4 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs4 = append(attrs4, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs4))
	}
	if len(x.GetExtraFiles()) != 0 {
		attrs5 := make([]slog.Attr, 0, len(x.GetExtraFiles()))
		for i, v := range x.GetExtraFiles() {
			attrs5 = append(attrs5, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_files", attrs5))
	}
	attrs = append(attrs, slog.String("console_reference_id", x.GetConsoleReferenceId()))
	attrs = append(attrs, slog.String("io_reference_id", x.GetIoReferenceId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCreateResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStartRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStartResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncExecRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetSpec() != nil {
		if v, ok := interface{}(x.GetSpec()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "spec", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("spec", x.GetSpec()))
		}
	}
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncProcessSpec) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Any("raw_json", x.GetRawJson()))
	return slog.GroupValue(attrs...)
}

func (x *RuncExecOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 5)
	attrs = append(attrs, slog.Bool("detach", x.GetDetach()))
	attrs = append(attrs, slog.String("pid_file", x.GetPidFile()))
	if len(x.GetExtraArgs()) != 0 {
		attrs2 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs2 = append(attrs2, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs2))
	}
	attrs = append(attrs, slog.String("io_reference_id", x.GetIoReferenceId()))
	attrs = append(attrs, slog.String("console_reference_id", x.GetConsoleReferenceId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncExecResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncRunRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.String("bundle", x.GetBundle()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncRunResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Int64("status", int64(x.GetStatus())))
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncDeleteRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncDeleteOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Bool("force", x.GetForce()))
	if len(x.GetExtraArgs()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs1 = append(attrs1, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs1))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncDeleteResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncKillRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.Int64("signal", int64(x.GetSignal())))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncKillOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Bool("all", x.GetAll()))
	if len(x.GetExtraArgs()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs1 = append(attrs1, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs1))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncKillResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStatsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStats) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Any("raw_json", x.GetRawJson()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStatsResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if x.GetStats() != nil {
		if v, ok := interface{}(x.GetStats()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "stats", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("stats", x.GetStats()))
		}
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncPauseRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncPauseResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncResumeRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncResumeResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncPsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncPsResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if len(x.GetPids()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetPids()))
		for i, v := range x.GetPids() {
			attrs0 = append(attrs0, slog.Int64(fmt.Sprintf("%d", i), int64(v)))
		}
		attrs = append(attrs, slog.Any("pids", attrs0))
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncVersionRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncVersionResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("runc", x.GetRunc()))
	attrs = append(attrs, slog.String("commit", x.GetCommit()))
	attrs = append(attrs, slog.String("spec", x.GetSpec()))
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCheckpointAction) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if len(x.GetAction()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetAction()))
		for i, v := range x.GetAction() {
			attrs0 = append(attrs0, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("action", attrs0))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncCheckpointRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	if len(x.GetActions()) != 0 {
		attrs2 := make([]slog.Attr, 0, len(x.GetActions()))
		for i, v := range x.GetActions() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs2 = append(attrs2, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs2 = append(attrs2, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("actions", attrs2))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncConsoleSocket) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("path", x.GetPath()))
	return slog.GroupValue(attrs...)
}

func (x *SetExecCommandOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("argc", x.GetArgc()))
	if len(x.GetArgv()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetArgv()))
		for i, v := range x.GetArgv() {
			attrs1 = append(attrs1, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("argv", attrs1))
	}
	if len(x.GetEnv()) != 0 {
		attrs2 := make([]slog.Attr, 0, len(x.GetEnv()))
		for k, v := range x.GetEnv() {
			attrs2 = append(attrs2, slog.String(fmt.Sprintf("%v", k), v))
		}
		attrs = append(attrs, slog.Any("env", attrs2))
	}
	attrs = append(attrs, slog.String("cwd", x.GetCwd()))
	return slog.GroupValue(attrs...)
}

func (x *RuncVsockIO) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.Uint64("stdin_vsock_port", x.GetStdinVsockPort()))
	attrs = append(attrs, slog.Uint64("stdout_vsock_port", x.GetStdoutVsockPort()))
	attrs = append(attrs, slog.Uint64("stderr_vsock_port", x.GetStderrVsockPort()))
	attrs = append(attrs, slog.Uint64("vsock_context_id", uint64(x.GetVsockContextId())))
	return slog.GroupValue(attrs...)
}

func (x *RuncUnixIO) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("stdin_path", x.GetStdinPath()))
	attrs = append(attrs, slog.String("stdout_path", x.GetStdoutPath()))
	attrs = append(attrs, slog.String("stderr_path", x.GetStderrPath()))
	return slog.GroupValue(attrs...)
}

func (x *RuncNullIO) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncIO) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("io_reference_id", x.GetIoReferenceId()))
	// Handle oneof field: Io
	switch x.WhichIo() {
	case RuncIO_Vsock_case:
		if msgValue, ok := interface{}(x.GetVsock()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "vsock", Value: msgValue.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("vsock", x.GetVsock()))
		}
	case RuncIO_Unix_case:
		if msgValue, ok := interface{}(x.GetUnix()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "unix", Value: msgValue.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("unix", x.GetUnix()))
		}
	case RuncIO_Null_case:
		if msgValue, ok := interface{}(x.GetNull()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "null", Value: msgValue.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("null", x.GetNull()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncCheckpointResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncRestoreRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.String("bundle", x.GetBundle()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncRestoreResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Int64("status", int64(x.GetStatus())))
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCheckpointOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 13)
	attrs = append(attrs, slog.String("image_path", x.GetImagePath()))
	attrs = append(attrs, slog.String("work_dir", x.GetWorkDir()))
	attrs = append(attrs, slog.String("parent_path", x.GetParentPath()))
	attrs = append(attrs, slog.Bool("allow_open_tcp", x.GetAllowOpenTcp()))
	attrs = append(attrs, slog.Bool("allow_external_unix_sockets", x.GetAllowExternalUnixSockets()))
	attrs = append(attrs, slog.Bool("allow_terminal", x.GetAllowTerminal()))
	attrs = append(attrs, slog.String("criu_page_server", x.GetCriuPageServer()))
	attrs = append(attrs, slog.Bool("file_locks", x.GetFileLocks()))
	attrs = append(attrs, slog.String("cgroups", x.GetCgroups()))
	if len(x.GetEmptyNamespaces()) != 0 {
		attrs9 := make([]slog.Attr, 0, len(x.GetEmptyNamespaces()))
		for i, v := range x.GetEmptyNamespaces() {
			attrs9 = append(attrs9, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("empty_namespaces", attrs9))
	}
	attrs = append(attrs, slog.Bool("lazy_pages", x.GetLazyPages()))
	attrs = append(attrs, slog.String("status_file", x.GetStatusFile()))
	if len(x.GetExtraArgs()) != 0 {
		attrs12 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs12 = append(attrs12, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs12))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncRestoreOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 8)
	if x.GetCheckpointOptions() != nil {
		if v, ok := interface{}(x.GetCheckpointOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "checkpoint_options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("checkpoint_options", x.GetCheckpointOptions()))
		}
	}
	attrs = append(attrs, slog.String("io_reference_id", x.GetIoReferenceId()))
	attrs = append(attrs, slog.Bool("detach", x.GetDetach()))
	attrs = append(attrs, slog.String("pid_file", x.GetPidFile()))
	attrs = append(attrs, slog.Bool("no_subreaper", x.GetNoSubreaper()))
	attrs = append(attrs, slog.Bool("no_pivot", x.GetNoPivot()))
	attrs = append(attrs, slog.String("console_reference_id", x.GetConsoleReferenceId()))
	if len(x.GetExtraArgs()) != 0 {
		attrs7 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs7 = append(attrs7, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs7))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncEventsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetDuration() != nil {
		if v, ok := interface{}(x.GetDuration()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "duration", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("duration", x.GetDuration()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncEvent) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("type", x.GetType()))
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetStats() != nil {
		if v, ok := interface{}(x.GetStats()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "stats", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("stats", x.GetStats()))
		}
	}
	attrs = append(attrs, slog.String("err", x.GetErr()))
	return slog.GroupValue(attrs...)
}

func (x *RuncUpdateRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetResources() != nil {
		if v, ok := interface{}(x.GetResources()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "resources", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("resources", x.GetResources()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncUpdateResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncLinuxResources) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Any("raw_json", x.GetRawJson()))
	return slog.GroupValue(attrs...)
}

func (x *RuncTopRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.String("ps_options", x.GetPsOptions()))
	return slog.GroupValue(attrs...)
}

func (x *RuncTopResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if x.GetResults() != nil {
		if v, ok := interface{}(x.GetResults()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "results", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("results", x.GetResults()))
		}
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncTopResults) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if len(x.GetHeaders()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetHeaders()))
		for i, v := range x.GetHeaders() {
			attrs0 = append(attrs0, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("headers", attrs0))
	}
	if len(x.GetProcesses()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetProcesses()))
		for i, v := range x.GetProcesses() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs1 = append(attrs1, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs1 = append(attrs1, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("processes", attrs1))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncTopProcesses) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if len(x.GetProcess()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetProcess()))
		for i, v := range x.GetProcess() {
			attrs0 = append(attrs0, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("process", attrs0))
	}
	return slog.GroupValue(attrs...)
}
