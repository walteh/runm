// Code generated by protoc-gen-slog-valuer. DO NOT EDIT.
//
// source: v1/runc.proto

package runvv1

import (
	fmt "fmt"
	slog "log/slog"
)

func (x *RuncLogFilePathRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncLogFilePathResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("path", x.GetPath()))
	return slog.GroupValue(attrs...)
}

func (x *PingRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *PingResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncListRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("root", x.GetRoot()))
	return slog.GroupValue(attrs...)
}

func (x *RuncContainer) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 7)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.Int64("pid", int64(x.GetPid())))
	attrs = append(attrs, slog.String("status", x.GetStatus()))
	attrs = append(attrs, slog.String("bundle", x.GetBundle()))
	attrs = append(attrs, slog.String("rootfs", x.GetRootfs()))
	attrs = append(attrs, slog.Int64("created_timestamp", x.GetCreatedTimestamp()))
	if len(x.GetAnnotations()) != 0 {
		attrs6 := make([]slog.Attr, 0, len(x.GetAnnotations()))
		for k, v := range x.GetAnnotations() {
			attrs6 = append(attrs6, slog.String(fmt.Sprintf("%v", k), v))
		}
		attrs = append(attrs, slog.Any("annotations", attrs6))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncListResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if len(x.GetContainers()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetContainers()))
		for i, v := range x.GetContainers() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs0 = append(attrs0, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs0 = append(attrs0, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("containers", attrs0))
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStateRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStateResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if x.GetContainer() != nil {
		if v, ok := interface{}(x.GetContainer()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "container", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("container", x.GetContainer()))
		}
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCreateRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.String("bundle", x.GetBundle()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncCreateOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 8)
	attrs = append(attrs, slog.Bool("detach", x.GetDetach()))
	attrs = append(attrs, slog.Bool("no_pivot", x.GetNoPivot()))
	attrs = append(attrs, slog.Bool("no_new_keyring", x.GetNoNewKeyring()))
	attrs = append(attrs, slog.String("pid_file", x.GetPidFile()))
	if len(x.GetExtraArgs()) != 0 {
		attrs4 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs4 = append(attrs4, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs4))
	}
	if len(x.GetExtraFiles()) != 0 {
		attrs5 := make([]slog.Attr, 0, len(x.GetExtraFiles()))
		for i, v := range x.GetExtraFiles() {
			attrs5 = append(attrs5, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_files", attrs5))
	}
	if x.GetConsoleSocket() != nil {
		if v, ok := interface{}(x.GetConsoleSocket()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "console_socket", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("console_socket", x.GetConsoleSocket()))
		}
	}
	if x.GetIo() != nil {
		if v, ok := interface{}(x.GetIo()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "io", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("io", x.GetIo()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncCreateResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStartRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStartResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncExecRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetSpec() != nil {
		if v, ok := interface{}(x.GetSpec()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "spec", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("spec", x.GetSpec()))
		}
	}
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncProcessSpec) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Any("raw_json", x.GetRawJson()))
	return slog.GroupValue(attrs...)
}

func (x *RuncExecOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.Bool("detach", x.GetDetach()))
	attrs = append(attrs, slog.String("pid_file", x.GetPidFile()))
	if len(x.GetExtraArgs()) != 0 {
		attrs2 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs2 = append(attrs2, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs2))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncExecResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncRunRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 7)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.String("bundle", x.GetBundle()))
	attrs = append(attrs, slog.Bool("detach", x.GetDetach()))
	attrs = append(attrs, slog.Bool("no_pivot", x.GetNoPivot()))
	attrs = append(attrs, slog.Bool("no_new_keyring", x.GetNoNewKeyring()))
	attrs = append(attrs, slog.String("pid_file", x.GetPidFile()))
	if len(x.GetExtraArgs()) != 0 {
		attrs6 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs6 = append(attrs6, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs6))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncRunResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Int64("status", int64(x.GetStatus())))
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncDeleteRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncDeleteOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Bool("force", x.GetForce()))
	if len(x.GetExtraArgs()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs1 = append(attrs1, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs1))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncDeleteResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncKillRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.Int64("signal", int64(x.GetSignal())))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncKillOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Bool("all", x.GetAll()))
	if len(x.GetExtraArgs()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs1 = append(attrs1, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs1))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncKillResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStatsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCpuUsage) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.Uint64("total", x.GetTotal()))
	if len(x.GetPercpu()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetPercpu()))
		for i, v := range x.GetPercpu() {
			attrs1 = append(attrs1, slog.Uint64(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("percpu", attrs1))
	}
	attrs = append(attrs, slog.Uint64("kernel", x.GetKernel()))
	attrs = append(attrs, slog.Uint64("user", x.GetUser()))
	return slog.GroupValue(attrs...)
}

func (x *RuncThrottling) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.Uint64("periods", x.GetPeriods()))
	attrs = append(attrs, slog.Uint64("throttled_periods", x.GetThrottledPeriods()))
	attrs = append(attrs, slog.Uint64("throttled_time", x.GetThrottledTime()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCpu) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if x.GetUsage() != nil {
		if v, ok := interface{}(x.GetUsage()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "usage", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("usage", x.GetUsage()))
		}
	}
	if x.GetThrottling() != nil {
		if v, ok := interface{}(x.GetThrottling()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "throttling", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("throttling", x.GetThrottling()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncMemoryEntry) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.Uint64("limit", x.GetLimit()))
	attrs = append(attrs, slog.Uint64("usage", x.GetUsage()))
	attrs = append(attrs, slog.Uint64("max", x.GetMax()))
	attrs = append(attrs, slog.Uint64("failcnt", x.GetFailcnt()))
	return slog.GroupValue(attrs...)
}

func (x *RuncMemory) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 6)
	attrs = append(attrs, slog.Uint64("cache", x.GetCache()))
	if x.GetUsage() != nil {
		if v, ok := interface{}(x.GetUsage()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "usage", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("usage", x.GetUsage()))
		}
	}
	if x.GetSwap() != nil {
		if v, ok := interface{}(x.GetSwap()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "swap", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("swap", x.GetSwap()))
		}
	}
	if x.GetKernel() != nil {
		if v, ok := interface{}(x.GetKernel()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "kernel", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("kernel", x.GetKernel()))
		}
	}
	if x.GetKernelTcp() != nil {
		if v, ok := interface{}(x.GetKernelTcp()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "kernel_tcp", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("kernel_tcp", x.GetKernelTcp()))
		}
	}
	if len(x.GetRaw()) != 0 {
		attrs5 := make([]slog.Attr, 0, len(x.GetRaw()))
		for k, v := range x.GetRaw() {
			attrs5 = append(attrs5, slog.Uint64(fmt.Sprintf("%v", k), v))
		}
		attrs = append(attrs, slog.Any("raw", attrs5))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncPids) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Uint64("current", x.GetCurrent()))
	attrs = append(attrs, slog.Uint64("limit", x.GetLimit()))
	return slog.GroupValue(attrs...)
}

func (x *RuncBlkioEntry) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.Uint64("major", x.GetMajor()))
	attrs = append(attrs, slog.Uint64("minor", x.GetMinor()))
	attrs = append(attrs, slog.String("op", x.GetOp()))
	attrs = append(attrs, slog.Uint64("value", x.GetValue()))
	return slog.GroupValue(attrs...)
}

func (x *RuncBlkio) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 8)
	if len(x.GetIoServiceBytesRecursive()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetIoServiceBytesRecursive()))
		for i, v := range x.GetIoServiceBytesRecursive() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs0 = append(attrs0, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs0 = append(attrs0, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("io_service_bytes_recursive", attrs0))
	}
	if len(x.GetIoServicedRecursive()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetIoServicedRecursive()))
		for i, v := range x.GetIoServicedRecursive() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs1 = append(attrs1, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs1 = append(attrs1, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("io_serviced_recursive", attrs1))
	}
	if len(x.GetIoQueuedRecursive()) != 0 {
		attrs2 := make([]slog.Attr, 0, len(x.GetIoQueuedRecursive()))
		for i, v := range x.GetIoQueuedRecursive() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs2 = append(attrs2, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs2 = append(attrs2, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("io_queued_recursive", attrs2))
	}
	if len(x.GetIoServiceTimeRecursive()) != 0 {
		attrs3 := make([]slog.Attr, 0, len(x.GetIoServiceTimeRecursive()))
		for i, v := range x.GetIoServiceTimeRecursive() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs3 = append(attrs3, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs3 = append(attrs3, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("io_service_time_recursive", attrs3))
	}
	if len(x.GetIoWaitTimeRecursive()) != 0 {
		attrs4 := make([]slog.Attr, 0, len(x.GetIoWaitTimeRecursive()))
		for i, v := range x.GetIoWaitTimeRecursive() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs4 = append(attrs4, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs4 = append(attrs4, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("io_wait_time_recursive", attrs4))
	}
	if len(x.GetIoMergedRecursive()) != 0 {
		attrs5 := make([]slog.Attr, 0, len(x.GetIoMergedRecursive()))
		for i, v := range x.GetIoMergedRecursive() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs5 = append(attrs5, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs5 = append(attrs5, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("io_merged_recursive", attrs5))
	}
	if len(x.GetIoTimeRecursive()) != 0 {
		attrs6 := make([]slog.Attr, 0, len(x.GetIoTimeRecursive()))
		for i, v := range x.GetIoTimeRecursive() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs6 = append(attrs6, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs6 = append(attrs6, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("io_time_recursive", attrs6))
	}
	if len(x.GetSectorsRecursive()) != 0 {
		attrs7 := make([]slog.Attr, 0, len(x.GetSectorsRecursive()))
		for i, v := range x.GetSectorsRecursive() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs7 = append(attrs7, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs7 = append(attrs7, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("sectors_recursive", attrs7))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncHugetlb) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.Uint64("usage", x.GetUsage()))
	attrs = append(attrs, slog.Uint64("max", x.GetMax()))
	attrs = append(attrs, slog.Uint64("failcnt", x.GetFailcnt()))
	return slog.GroupValue(attrs...)
}

func (x *RuncNetworkInterface) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 9)
	attrs = append(attrs, slog.String("name", x.GetName()))
	attrs = append(attrs, slog.Uint64("rx_bytes", x.GetRxBytes()))
	attrs = append(attrs, slog.Uint64("rx_packets", x.GetRxPackets()))
	attrs = append(attrs, slog.Uint64("rx_errors", x.GetRxErrors()))
	attrs = append(attrs, slog.Uint64("rx_dropped", x.GetRxDropped()))
	attrs = append(attrs, slog.Uint64("tx_bytes", x.GetTxBytes()))
	attrs = append(attrs, slog.Uint64("tx_packets", x.GetTxPackets()))
	attrs = append(attrs, slog.Uint64("tx_errors", x.GetTxErrors()))
	attrs = append(attrs, slog.Uint64("tx_dropped", x.GetTxDropped()))
	return slog.GroupValue(attrs...)
}

func (x *RuncStats) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 6)
	if x.GetCpu() != nil {
		if v, ok := interface{}(x.GetCpu()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "cpu", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("cpu", x.GetCpu()))
		}
	}
	if x.GetMemory() != nil {
		if v, ok := interface{}(x.GetMemory()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "memory", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("memory", x.GetMemory()))
		}
	}
	if x.GetPids() != nil {
		if v, ok := interface{}(x.GetPids()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "pids", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("pids", x.GetPids()))
		}
	}
	if x.GetBlkio() != nil {
		if v, ok := interface{}(x.GetBlkio()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "blkio", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("blkio", x.GetBlkio()))
		}
	}
	if len(x.GetHugetlb()) != 0 {
		attrs4 := make([]slog.Attr, 0, len(x.GetHugetlb()))
		for k, v := range x.GetHugetlb() {
			if vv, ok := interface{}(v).(slog.LogValuer); ok {
				attrs4 = append(attrs4, slog.Attr{Key: fmt.Sprintf("%v", k), Value: vv.LogValue()})
			} else {
				attrs4 = append(attrs4, slog.Any(fmt.Sprintf("%v", k), v))
			}
		}
		attrs = append(attrs, slog.Any("hugetlb", attrs4))
	}
	if len(x.GetNetworkInterfaces()) != 0 {
		attrs5 := make([]slog.Attr, 0, len(x.GetNetworkInterfaces()))
		for i, v := range x.GetNetworkInterfaces() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs5 = append(attrs5, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs5 = append(attrs5, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("network_interfaces", attrs5))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncStatsResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if x.GetStats() != nil {
		if v, ok := interface{}(x.GetStats()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "stats", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("stats", x.GetStats()))
		}
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncPauseRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncPauseResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncResumeRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncResumeResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncPsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("id", x.GetId()))
	return slog.GroupValue(attrs...)
}

func (x *RuncPsResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	if len(x.GetPids()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetPids()))
		for i, v := range x.GetPids() {
			attrs0 = append(attrs0, slog.Int64(fmt.Sprintf("%d", i), int64(v)))
		}
		attrs = append(attrs, slog.Any("pids", attrs0))
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncTopRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.String("ps_options", x.GetPsOptions()))
	return slog.GroupValue(attrs...)
}

func (x *RuncTopResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	if len(x.GetHeaders()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetHeaders()))
		for i, v := range x.GetHeaders() {
			attrs0 = append(attrs0, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("headers", attrs0))
	}
	if len(x.GetProcesses()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetProcesses()))
		for i, v := range x.GetProcesses() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs1 = append(attrs1, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs1 = append(attrs1, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("processes", attrs1))
	}
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncProcessData) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if len(x.GetData()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetData()))
		for i, v := range x.GetData() {
			attrs0 = append(attrs0, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("data", attrs0))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncVersionRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *RuncVersionResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("runc", x.GetRunc()))
	attrs = append(attrs, slog.String("commit", x.GetCommit()))
	attrs = append(attrs, slog.String("spec", x.GetSpec()))
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCheckpointAction) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if len(x.GetAction()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetAction()))
		for i, v := range x.GetAction() {
			attrs0 = append(attrs0, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("action", attrs0))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncCheckpointRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	if len(x.GetActions()) != 0 {
		attrs2 := make([]slog.Attr, 0, len(x.GetActions()))
		for i, v := range x.GetActions() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs2 = append(attrs2, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs2 = append(attrs2, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("actions", attrs2))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncConsoleSocket) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("path", x.GetPath()))
	return slog.GroupValue(attrs...)
}

func (x *SetExecCommandOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("argc", x.GetArgc()))
	if len(x.GetArgv()) != 0 {
		attrs1 := make([]slog.Attr, 0, len(x.GetArgv()))
		for i, v := range x.GetArgv() {
			attrs1 = append(attrs1, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("argv", attrs1))
	}
	if len(x.GetEnv()) != 0 {
		attrs2 := make([]slog.Attr, 0, len(x.GetEnv()))
		for k, v := range x.GetEnv() {
			attrs2 = append(attrs2, slog.String(fmt.Sprintf("%v", k), v))
		}
		attrs = append(attrs, slog.Any("env", attrs2))
	}
	attrs = append(attrs, slog.String("cwd", x.GetCwd()))
	return slog.GroupValue(attrs...)
}

func (x *RuncIO) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("stdin_path", x.GetStdinPath()))
	attrs = append(attrs, slog.String("stdout_path", x.GetStdoutPath()))
	attrs = append(attrs, slog.String("stderr_path", x.GetStderrPath()))
	if x.GetSetExecCommandOptions() != nil {
		if v, ok := interface{}(x.GetSetExecCommandOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "set_exec_command_options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("set_exec_command_options", x.GetSetExecCommandOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncCheckpointResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncRestoreRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 3)
	attrs = append(attrs, slog.String("id", x.GetId()))
	attrs = append(attrs, slog.String("bundle", x.GetBundle()))
	if x.GetOptions() != nil {
		if v, ok := interface{}(x.GetOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("options", x.GetOptions()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncRestoreResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.Int64("status", int64(x.GetStatus())))
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncCheckpointOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 13)
	attrs = append(attrs, slog.String("image_path", x.GetImagePath()))
	attrs = append(attrs, slog.String("work_dir", x.GetWorkDir()))
	attrs = append(attrs, slog.String("parent_path", x.GetParentPath()))
	attrs = append(attrs, slog.Bool("allow_open_tcp", x.GetAllowOpenTcp()))
	attrs = append(attrs, slog.Bool("allow_external_unix_sockets", x.GetAllowExternalUnixSockets()))
	attrs = append(attrs, slog.Bool("allow_terminal", x.GetAllowTerminal()))
	attrs = append(attrs, slog.String("criu_page_server", x.GetCriuPageServer()))
	attrs = append(attrs, slog.Bool("file_locks", x.GetFileLocks()))
	attrs = append(attrs, slog.String("cgroups", x.GetCgroups()))
	if len(x.GetEmptyNamespaces()) != 0 {
		attrs9 := make([]slog.Attr, 0, len(x.GetEmptyNamespaces()))
		for i, v := range x.GetEmptyNamespaces() {
			attrs9 = append(attrs9, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("empty_namespaces", attrs9))
	}
	attrs = append(attrs, slog.Bool("lazy_pages", x.GetLazyPages()))
	attrs = append(attrs, slog.String("status_file", x.GetStatusFile()))
	if len(x.GetExtraArgs()) != 0 {
		attrs12 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs12 = append(attrs12, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs12))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncRestoreOptions) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 8)
	if x.GetCheckpointOptions() != nil {
		if v, ok := interface{}(x.GetCheckpointOptions()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "checkpoint_options", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("checkpoint_options", x.GetCheckpointOptions()))
		}
	}
	if x.GetIo() != nil {
		if v, ok := interface{}(x.GetIo()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "io", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("io", x.GetIo()))
		}
	}
	attrs = append(attrs, slog.Bool("detach", x.GetDetach()))
	attrs = append(attrs, slog.String("pid_file", x.GetPidFile()))
	attrs = append(attrs, slog.Bool("no_subreaper", x.GetNoSubreaper()))
	attrs = append(attrs, slog.Bool("no_pivot", x.GetNoPivot()))
	if x.GetConsoleSocket() != nil {
		if v, ok := interface{}(x.GetConsoleSocket()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "console_socket", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("console_socket", x.GetConsoleSocket()))
		}
	}
	if len(x.GetExtraArgs()) != 0 {
		attrs7 := make([]slog.Attr, 0, len(x.GetExtraArgs()))
		for i, v := range x.GetExtraArgs() {
			attrs7 = append(attrs7, slog.String(fmt.Sprintf("%d", i), v))
		}
		attrs = append(attrs, slog.Any("extra_args", attrs7))
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncEventsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetDuration() != nil {
		if v, ok := interface{}(x.GetDuration()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "duration", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("duration", x.GetDuration()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncEvent) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("type", x.GetType()))
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetStats() != nil {
		if v, ok := interface{}(x.GetStats()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "stats", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("stats", x.GetStats()))
		}
	}
	attrs = append(attrs, slog.String("err", x.GetErr()))
	return slog.GroupValue(attrs...)
}

func (x *RuncUpdateRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("id", x.GetId()))
	if x.GetResources() != nil {
		if v, ok := interface{}(x.GetResources()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "resources", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("resources", x.GetResources()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *RuncUpdateResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *RuncLinuxResources) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Any("raw_json", x.GetRawJson()))
	return slog.GroupValue(attrs...)
}
