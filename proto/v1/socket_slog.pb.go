// Code generated by protoc-gen-go-slog. DO NOT EDIT.
//
// source: v1/socket.proto

package runmv1

import (
	fmt "fmt"
	slog "log/slog"
)

func (x *VsockPort) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Uint64("port", uint64(x.GetPort())))
	return slog.GroupValue(attrs...)
}

func (x *UnixSocketPath) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("path", x.GetPath()))
	return slog.GroupValue(attrs...)
}

func (x *SocketType) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	// Handle oneof field: Type
	switch x.WhichType() {
	case SocketType_VsockPort_case:
		if msgValue, ok := interface{}(x.GetVsockPort()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "vsock_port", Value: msgValue.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("vsock_port", x.GetVsockPort()))
		}
	case SocketType_UnixSocketPath_case:
		if msgValue, ok := interface{}(x.GetUnixSocketPath()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "unix_socket_path", Value: msgValue.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("unix_socket_path", x.GetUnixSocketPath()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *DialOpenListenerRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if x.GetListeningOn() != nil {
		if v, ok := interface{}(x.GetListeningOn()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "listening_on", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("listening_on", x.GetListeningOn()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *DialOpenListenerResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *AllocateSocketStreamRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *AllocateSocketStreamResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if x.GetSocketType() != nil {
		if v, ok := interface{}(x.GetSocketType()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "socket_type", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("socket_type", x.GetSocketType()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *AllocateIORequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 5)
	attrs = append(attrs, slog.Bool("open_stdin", x.GetOpenStdin()))
	attrs = append(attrs, slog.Bool("open_stdout", x.GetOpenStdout()))
	attrs = append(attrs, slog.Bool("open_stderr", x.GetOpenStderr()))
	attrs = append(attrs, slog.Int64("io_uid", int64(x.GetIoUid())))
	attrs = append(attrs, slog.Int64("io_gid", int64(x.GetIoGid())))
	return slog.GroupValue(attrs...)
}

func (x *AllocateIOResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("io_reference_id", x.GetIoReferenceId()))
	return slog.GroupValue(attrs...)
}

func (x *AllocateConsoleRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *AllocateConsoleResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("console_reference_id", x.GetConsoleReferenceId()))
	return slog.GroupValue(attrs...)
}

func (x *CloseSocketsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if len(x.GetSocketTypes()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetSocketTypes()))
		for i, v := range x.GetSocketTypes() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs0 = append(attrs0, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs0 = append(attrs0, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("socket_types", attrs0))
	}
	return slog.GroupValue(attrs...)
}

func (x *CloseSocketsResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *AllocateSocketsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Uint64("count", uint64(x.GetCount())))
	return slog.GroupValue(attrs...)
}

func (x *AllocateSocketsResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if len(x.GetSocketTypes()) != 0 {
		attrs0 := make([]slog.Attr, 0, len(x.GetSocketTypes()))
		for i, v := range x.GetSocketTypes() {
			if v, ok := interface{}(v).(slog.LogValuer); ok {
				attrs0 = append(attrs0, slog.Attr{Key: fmt.Sprintf("%d", i), Value: v.LogValue()})
			} else {
				attrs0 = append(attrs0, slog.Any(fmt.Sprintf("%d", i), v))
			}
		}
		attrs = append(attrs, slog.Any("socket_types", attrs0))
	}
	return slog.GroupValue(attrs...)
}

func (x *BindIOToSocketsRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 4)
	attrs = append(attrs, slog.String("io_reference_id", x.GetIoReferenceId()))
	if x.GetStdinSocket() != nil {
		if v, ok := interface{}(x.GetStdinSocket()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "stdin_socket", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("stdin_socket", x.GetStdinSocket()))
		}
	}
	if x.GetStdoutSocket() != nil {
		if v, ok := interface{}(x.GetStdoutSocket()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "stdout_socket", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("stdout_socket", x.GetStdoutSocket()))
		}
	}
	if x.GetStderrSocket() != nil {
		if v, ok := interface{}(x.GetStderrSocket()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "stderr_socket", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("stderr_socket", x.GetStderrSocket()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *BindIOToSocketsResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *BindConsoleToSocketRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 2)
	attrs = append(attrs, slog.String("console_reference_id", x.GetConsoleReferenceId()))
	if x.GetSocketType() != nil {
		if v, ok := interface{}(x.GetSocketType()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "socket_type", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("socket_type", x.GetSocketType()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *BindConsoleToSocketResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *AllocateSocketRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.Uint64("count", uint64(x.GetCount())))
	return slog.GroupValue(attrs...)
}

func (x *AllocateSocketResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if x.GetSocketType() != nil {
		if v, ok := interface{}(x.GetSocketType()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "socket_type", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("socket_type", x.GetSocketType()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *CloseSocketRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	if x.GetSocketType() != nil {
		if v, ok := interface{}(x.GetSocketType()).(slog.LogValuer); ok {
			attrs = append(attrs, slog.Attr{Key: "socket_type", Value: v.LogValue()})
		} else {
			attrs = append(attrs, slog.Any("socket_type", x.GetSocketType()))
		}
	}
	return slog.GroupValue(attrs...)
}

func (x *CloseSocketResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("go_error", x.GetGoError()))
	return slog.GroupValue(attrs...)
}

func (x *CloseIORequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("io_reference_id", x.GetIoReferenceId()))
	return slog.GroupValue(attrs...)
}

func (x *CloseIOResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}

func (x *CloseConsoleRequest) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 1)
	attrs = append(attrs, slog.String("console_reference_id", x.GetConsoleReferenceId()))
	return slog.GroupValue(attrs...)
}

func (x *CloseConsoleResponse) LogValue() slog.Value {
	if x == nil {
		return slog.AnyValue(nil)
	}
	attrs := make([]slog.Attr, 0, 0)
	return slog.GroupValue(attrs...)
}
