// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockvmm

import (
	"context"
	"sync"

	"github.com/walteh/runm/core/virt/virtio"
	"github.com/walteh/runm/core/virt/vmm"
)

// Ensure that MockHypervisor does implement vmm.Hypervisor.
// If this is not the case, regenerate this file with mockery.
var _ vmm.Hypervisor[vmm.VirtualMachine] = &MockHypervisor[vmm.VirtualMachine]{}

// MockHypervisor is a mock implementation of vmm.Hypervisor.
//
//	func TestSomethingThatUsesHypervisor(t *testing.T) {
//
//		// make and configure a mocked vmm.Hypervisor
//		mockedHypervisor := &MockHypervisor{
//			NewVirtualMachineFunc: func(ctx context.Context, id string, opts *vmm.NewVMOptions, bootLoader virtio.Bootloader) (VM, error) {
//				panic("mock out the NewVirtualMachine method")
//			},
//			OnCreateFunc: func() <-chan VM {
//				panic("mock out the OnCreate method")
//			},
//		}
//
//		// use mockedHypervisor in code that requires vmm.Hypervisor
//		// and then make assertions.
//
//	}
type MockHypervisor[VM vmm.VirtualMachine] struct {
	// NewVirtualMachineFunc mocks the NewVirtualMachine method.
	NewVirtualMachineFunc func(ctx context.Context, id string, opts *vmm.NewVMOptions, bootLoader virtio.Bootloader) (VM, error)

	// OnCreateFunc mocks the OnCreate method.
	OnCreateFunc func() <-chan VM

	// calls tracks calls to the methods.
	calls struct {
		// NewVirtualMachine holds details about calls to the NewVirtualMachine method.
		NewVirtualMachine []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Opts is the opts argument value.
			Opts *vmm.NewVMOptions
			// BootLoader is the bootLoader argument value.
			BootLoader virtio.Bootloader
		}
		// OnCreate holds details about calls to the OnCreate method.
		OnCreate []struct {
		}
	}
	lockNewVirtualMachine sync.RWMutex
	lockOnCreate          sync.RWMutex
}

// NewVirtualMachine calls NewVirtualMachineFunc.
func (mock *MockHypervisor[VM]) NewVirtualMachine(ctx context.Context, id string, opts *vmm.NewVMOptions, bootLoader virtio.Bootloader) (VM, error) {
	if mock.NewVirtualMachineFunc == nil {
		panic("MockHypervisor.NewVirtualMachineFunc: method is nil but Hypervisor.NewVirtualMachine was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ID         string
		Opts       *vmm.NewVMOptions
		BootLoader virtio.Bootloader
	}{
		Ctx:        ctx,
		ID:         id,
		Opts:       opts,
		BootLoader: bootLoader,
	}
	mock.lockNewVirtualMachine.Lock()
	mock.calls.NewVirtualMachine = append(mock.calls.NewVirtualMachine, callInfo)
	mock.lockNewVirtualMachine.Unlock()
	return mock.NewVirtualMachineFunc(ctx, id, opts, bootLoader)
}

// NewVirtualMachineCalls gets all the calls that were made to NewVirtualMachine.
// Check the length with:
//
//	len(mockedHypervisor.NewVirtualMachineCalls())
func (mock *MockHypervisor[VM]) NewVirtualMachineCalls() []struct {
	Ctx        context.Context
	ID         string
	Opts       *vmm.NewVMOptions
	BootLoader virtio.Bootloader
} {
	var calls []struct {
		Ctx        context.Context
		ID         string
		Opts       *vmm.NewVMOptions
		BootLoader virtio.Bootloader
	}
	mock.lockNewVirtualMachine.RLock()
	calls = mock.calls.NewVirtualMachine
	mock.lockNewVirtualMachine.RUnlock()
	return calls
}

// OnCreate calls OnCreateFunc.
func (mock *MockHypervisor[VM]) OnCreate() <-chan VM {
	if mock.OnCreateFunc == nil {
		panic("MockHypervisor.OnCreateFunc: method is nil but Hypervisor.OnCreate was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOnCreate.Lock()
	mock.calls.OnCreate = append(mock.calls.OnCreate, callInfo)
	mock.lockOnCreate.Unlock()
	return mock.OnCreateFunc()
}

// OnCreateCalls gets all the calls that were made to OnCreate.
// Check the length with:
//
//	len(mockedHypervisor.OnCreateCalls())
func (mock *MockHypervisor[VM]) OnCreateCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOnCreate.RLock()
	calls = mock.calls.OnCreate
	mock.lockOnCreate.RUnlock()
	return calls
}
