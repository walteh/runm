// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockvmm

import (
	"context"
	"net"
	"sync"

	"github.com/containers/common/pkg/strongunits"
	"github.com/walteh/runm/core/virt/virtio"
	"github.com/walteh/runm/core/virt/vmm"
)

// Ensure that MockVirtualMachine does implement vmm.VirtualMachine.
// If this is not the case, regenerate this file with mockery.
var _ vmm.VirtualMachine = &MockVirtualMachine{}

// MockVirtualMachine is a mock implementation of vmm.VirtualMachine.
//
//	func TestSomethingThatUsesVirtualMachine(t *testing.T) {
//
//		// make and configure a mocked vmm.VirtualMachine
//		mockedVirtualMachine := &MockVirtualMachine{
//			CanHardStopFunc: func(ctx context.Context) bool {
//				panic("mock out the CanHardStop method")
//			},
//			CanPauseFunc: func(ctx context.Context) bool {
//				panic("mock out the CanPause method")
//			},
//			CanRequestStopFunc: func(ctx context.Context) bool {
//				panic("mock out the CanRequestStop method")
//			},
//			CanResumeFunc: func(ctx context.Context) bool {
//				panic("mock out the CanResume method")
//			},
//			CanStartFunc: func(ctx context.Context) bool {
//				panic("mock out the CanStart method")
//			},
//			CurrentStateFunc: func() vmm.VirtualMachineStateType {
//				panic("mock out the CurrentState method")
//			},
//			DevicesFunc: func() []virtio.VirtioDevice {
//				panic("mock out the Devices method")
//			},
//			GetMemoryBalloonTargetSizeFunc: func(ctx context.Context) (strongunits.B, error) {
//				panic("mock out the GetMemoryBalloonTargetSize method")
//			},
//			HardStopFunc: func(ctx context.Context) error {
//				panic("mock out the HardStop method")
//			},
//			IDFunc: func() string {
//				panic("mock out the ID method")
//			},
//			OptsFunc: func() *vmm.NewVMOptions {
//				panic("mock out the Opts method")
//			},
//			PauseFunc: func(ctx context.Context) error {
//				panic("mock out the Pause method")
//			},
//			RequestStopFunc: func(ctx context.Context) (bool, error) {
//				panic("mock out the RequestStop method")
//			},
//			RestoreFromFullSnapshotFunc: func(ctx context.Context, path string) error {
//				panic("mock out the RestoreFromFullSnapshot method")
//			},
//			ResumeFunc: func(ctx context.Context) error {
//				panic("mock out the Resume method")
//			},
//			SaveFullSnapshotFunc: func(ctx context.Context, path string) error {
//				panic("mock out the SaveFullSnapshot method")
//			},
//			ServeBackgroundTasksFunc: func(ctx context.Context) error {
//				panic("mock out the ServeBackgroundTasks method")
//			},
//			SetMemoryBalloonTargetSizeFunc: func(ctx context.Context, targetBytes strongunits.B) error {
//				panic("mock out the SetMemoryBalloonTargetSize method")
//			},
//			StartFunc: func(ctx context.Context) error {
//				panic("mock out the Start method")
//			},
//			StartGraphicApplicationFunc: func(width float64, height float64) error {
//				panic("mock out the StartGraphicApplication method")
//			},
//			StateChangeNotifyFunc: func(ctx context.Context) <-chan vmm.VirtualMachineStateChange {
//				panic("mock out the StateChangeNotify method")
//			},
//			VSockConnectFunc: func(ctx context.Context, port uint32) (net.Conn, error) {
//				panic("mock out the VSockConnect method")
//			},
//			VSockListenFunc: func(ctx context.Context, port uint32) (net.Listener, error) {
//				panic("mock out the VSockListen method")
//			},
//		}
//
//		// use mockedVirtualMachine in code that requires vmm.VirtualMachine
//		// and then make assertions.
//
//	}
type MockVirtualMachine struct {
	// CanHardStopFunc mocks the CanHardStop method.
	CanHardStopFunc func(ctx context.Context) bool

	// CanPauseFunc mocks the CanPause method.
	CanPauseFunc func(ctx context.Context) bool

	// CanRequestStopFunc mocks the CanRequestStop method.
	CanRequestStopFunc func(ctx context.Context) bool

	// CanResumeFunc mocks the CanResume method.
	CanResumeFunc func(ctx context.Context) bool

	// CanStartFunc mocks the CanStart method.
	CanStartFunc func(ctx context.Context) bool

	// CurrentStateFunc mocks the CurrentState method.
	CurrentStateFunc func() vmm.VirtualMachineStateType

	// DevicesFunc mocks the Devices method.
	DevicesFunc func() []virtio.VirtioDevice

	// GetMemoryBalloonTargetSizeFunc mocks the GetMemoryBalloonTargetSize method.
	GetMemoryBalloonTargetSizeFunc func(ctx context.Context) (strongunits.B, error)

	// HardStopFunc mocks the HardStop method.
	HardStopFunc func(ctx context.Context) error

	// IDFunc mocks the ID method.
	IDFunc func() string

	// OptsFunc mocks the Opts method.
	OptsFunc func() *vmm.NewVMOptions

	// PauseFunc mocks the Pause method.
	PauseFunc func(ctx context.Context) error

	// RequestStopFunc mocks the RequestStop method.
	RequestStopFunc func(ctx context.Context) (bool, error)

	// RestoreFromFullSnapshotFunc mocks the RestoreFromFullSnapshot method.
	RestoreFromFullSnapshotFunc func(ctx context.Context, path string) error

	// ResumeFunc mocks the Resume method.
	ResumeFunc func(ctx context.Context) error

	// SaveFullSnapshotFunc mocks the SaveFullSnapshot method.
	SaveFullSnapshotFunc func(ctx context.Context, path string) error

	// ServeBackgroundTasksFunc mocks the ServeBackgroundTasks method.
	ServeBackgroundTasksFunc func(ctx context.Context) error

	// SetMemoryBalloonTargetSizeFunc mocks the SetMemoryBalloonTargetSize method.
	SetMemoryBalloonTargetSizeFunc func(ctx context.Context, targetBytes strongunits.B) error

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context) error

	// StartGraphicApplicationFunc mocks the StartGraphicApplication method.
	StartGraphicApplicationFunc func(width float64, height float64) error

	// StateChangeNotifyFunc mocks the StateChangeNotify method.
	StateChangeNotifyFunc func(ctx context.Context) <-chan vmm.VirtualMachineStateChange

	// VSockConnectFunc mocks the VSockConnect method.
	VSockConnectFunc func(ctx context.Context, port uint32) (net.Conn, error)

	// VSockListenFunc mocks the VSockListen method.
	VSockListenFunc func(ctx context.Context, port uint32) (net.Listener, error)

	// calls tracks calls to the methods.
	calls struct {
		// CanHardStop holds details about calls to the CanHardStop method.
		CanHardStop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CanPause holds details about calls to the CanPause method.
		CanPause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CanRequestStop holds details about calls to the CanRequestStop method.
		CanRequestStop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CanResume holds details about calls to the CanResume method.
		CanResume []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CanStart holds details about calls to the CanStart method.
		CanStart []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CurrentState holds details about calls to the CurrentState method.
		CurrentState []struct {
		}
		// Devices holds details about calls to the Devices method.
		Devices []struct {
		}
		// GetMemoryBalloonTargetSize holds details about calls to the GetMemoryBalloonTargetSize method.
		GetMemoryBalloonTargetSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// HardStop holds details about calls to the HardStop method.
		HardStop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// Opts holds details about calls to the Opts method.
		Opts []struct {
		}
		// Pause holds details about calls to the Pause method.
		Pause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RequestStop holds details about calls to the RequestStop method.
		RequestStop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RestoreFromFullSnapshot holds details about calls to the RestoreFromFullSnapshot method.
		RestoreFromFullSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
		}
		// Resume holds details about calls to the Resume method.
		Resume []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SaveFullSnapshot holds details about calls to the SaveFullSnapshot method.
		SaveFullSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
		}
		// ServeBackgroundTasks holds details about calls to the ServeBackgroundTasks method.
		ServeBackgroundTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SetMemoryBalloonTargetSize holds details about calls to the SetMemoryBalloonTargetSize method.
		SetMemoryBalloonTargetSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TargetBytes is the targetBytes argument value.
			TargetBytes strongunits.B
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// StartGraphicApplication holds details about calls to the StartGraphicApplication method.
		StartGraphicApplication []struct {
			// Width is the width argument value.
			Width float64
			// Height is the height argument value.
			Height float64
		}
		// StateChangeNotify holds details about calls to the StateChangeNotify method.
		StateChangeNotify []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// VSockConnect holds details about calls to the VSockConnect method.
		VSockConnect []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Port is the port argument value.
			Port uint32
		}
		// VSockListen holds details about calls to the VSockListen method.
		VSockListen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Port is the port argument value.
			Port uint32
		}
	}
	lockCanHardStop                sync.RWMutex
	lockCanPause                   sync.RWMutex
	lockCanRequestStop             sync.RWMutex
	lockCanResume                  sync.RWMutex
	lockCanStart                   sync.RWMutex
	lockCurrentState               sync.RWMutex
	lockDevices                    sync.RWMutex
	lockGetMemoryBalloonTargetSize sync.RWMutex
	lockHardStop                   sync.RWMutex
	lockID                         sync.RWMutex
	lockOpts                       sync.RWMutex
	lockPause                      sync.RWMutex
	lockRequestStop                sync.RWMutex
	lockRestoreFromFullSnapshot    sync.RWMutex
	lockResume                     sync.RWMutex
	lockSaveFullSnapshot           sync.RWMutex
	lockServeBackgroundTasks       sync.RWMutex
	lockSetMemoryBalloonTargetSize sync.RWMutex
	lockStart                      sync.RWMutex
	lockStartGraphicApplication    sync.RWMutex
	lockStateChangeNotify          sync.RWMutex
	lockVSockConnect               sync.RWMutex
	lockVSockListen                sync.RWMutex
}

// CanHardStop calls CanHardStopFunc.
func (mock *MockVirtualMachine) CanHardStop(ctx context.Context) bool {
	if mock.CanHardStopFunc == nil {
		panic("MockVirtualMachine.CanHardStopFunc: method is nil but VirtualMachine.CanHardStop was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCanHardStop.Lock()
	mock.calls.CanHardStop = append(mock.calls.CanHardStop, callInfo)
	mock.lockCanHardStop.Unlock()
	return mock.CanHardStopFunc(ctx)
}

// CanHardStopCalls gets all the calls that were made to CanHardStop.
// Check the length with:
//
//	len(mockedVirtualMachine.CanHardStopCalls())
func (mock *MockVirtualMachine) CanHardStopCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCanHardStop.RLock()
	calls = mock.calls.CanHardStop
	mock.lockCanHardStop.RUnlock()
	return calls
}

// CanPause calls CanPauseFunc.
func (mock *MockVirtualMachine) CanPause(ctx context.Context) bool {
	if mock.CanPauseFunc == nil {
		panic("MockVirtualMachine.CanPauseFunc: method is nil but VirtualMachine.CanPause was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCanPause.Lock()
	mock.calls.CanPause = append(mock.calls.CanPause, callInfo)
	mock.lockCanPause.Unlock()
	return mock.CanPauseFunc(ctx)
}

// CanPauseCalls gets all the calls that were made to CanPause.
// Check the length with:
//
//	len(mockedVirtualMachine.CanPauseCalls())
func (mock *MockVirtualMachine) CanPauseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCanPause.RLock()
	calls = mock.calls.CanPause
	mock.lockCanPause.RUnlock()
	return calls
}

// CanRequestStop calls CanRequestStopFunc.
func (mock *MockVirtualMachine) CanRequestStop(ctx context.Context) bool {
	if mock.CanRequestStopFunc == nil {
		panic("MockVirtualMachine.CanRequestStopFunc: method is nil but VirtualMachine.CanRequestStop was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCanRequestStop.Lock()
	mock.calls.CanRequestStop = append(mock.calls.CanRequestStop, callInfo)
	mock.lockCanRequestStop.Unlock()
	return mock.CanRequestStopFunc(ctx)
}

// CanRequestStopCalls gets all the calls that were made to CanRequestStop.
// Check the length with:
//
//	len(mockedVirtualMachine.CanRequestStopCalls())
func (mock *MockVirtualMachine) CanRequestStopCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCanRequestStop.RLock()
	calls = mock.calls.CanRequestStop
	mock.lockCanRequestStop.RUnlock()
	return calls
}

// CanResume calls CanResumeFunc.
func (mock *MockVirtualMachine) CanResume(ctx context.Context) bool {
	if mock.CanResumeFunc == nil {
		panic("MockVirtualMachine.CanResumeFunc: method is nil but VirtualMachine.CanResume was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCanResume.Lock()
	mock.calls.CanResume = append(mock.calls.CanResume, callInfo)
	mock.lockCanResume.Unlock()
	return mock.CanResumeFunc(ctx)
}

// CanResumeCalls gets all the calls that were made to CanResume.
// Check the length with:
//
//	len(mockedVirtualMachine.CanResumeCalls())
func (mock *MockVirtualMachine) CanResumeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCanResume.RLock()
	calls = mock.calls.CanResume
	mock.lockCanResume.RUnlock()
	return calls
}

// CanStart calls CanStartFunc.
func (mock *MockVirtualMachine) CanStart(ctx context.Context) bool {
	if mock.CanStartFunc == nil {
		panic("MockVirtualMachine.CanStartFunc: method is nil but VirtualMachine.CanStart was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCanStart.Lock()
	mock.calls.CanStart = append(mock.calls.CanStart, callInfo)
	mock.lockCanStart.Unlock()
	return mock.CanStartFunc(ctx)
}

// CanStartCalls gets all the calls that were made to CanStart.
// Check the length with:
//
//	len(mockedVirtualMachine.CanStartCalls())
func (mock *MockVirtualMachine) CanStartCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCanStart.RLock()
	calls = mock.calls.CanStart
	mock.lockCanStart.RUnlock()
	return calls
}

// CurrentState calls CurrentStateFunc.
func (mock *MockVirtualMachine) CurrentState() vmm.VirtualMachineStateType {
	if mock.CurrentStateFunc == nil {
		panic("MockVirtualMachine.CurrentStateFunc: method is nil but VirtualMachine.CurrentState was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCurrentState.Lock()
	mock.calls.CurrentState = append(mock.calls.CurrentState, callInfo)
	mock.lockCurrentState.Unlock()
	return mock.CurrentStateFunc()
}

// CurrentStateCalls gets all the calls that were made to CurrentState.
// Check the length with:
//
//	len(mockedVirtualMachine.CurrentStateCalls())
func (mock *MockVirtualMachine) CurrentStateCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCurrentState.RLock()
	calls = mock.calls.CurrentState
	mock.lockCurrentState.RUnlock()
	return calls
}

// Devices calls DevicesFunc.
func (mock *MockVirtualMachine) Devices() []virtio.VirtioDevice {
	if mock.DevicesFunc == nil {
		panic("MockVirtualMachine.DevicesFunc: method is nil but VirtualMachine.Devices was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDevices.Lock()
	mock.calls.Devices = append(mock.calls.Devices, callInfo)
	mock.lockDevices.Unlock()
	return mock.DevicesFunc()
}

// DevicesCalls gets all the calls that were made to Devices.
// Check the length with:
//
//	len(mockedVirtualMachine.DevicesCalls())
func (mock *MockVirtualMachine) DevicesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDevices.RLock()
	calls = mock.calls.Devices
	mock.lockDevices.RUnlock()
	return calls
}

// GetMemoryBalloonTargetSize calls GetMemoryBalloonTargetSizeFunc.
func (mock *MockVirtualMachine) GetMemoryBalloonTargetSize(ctx context.Context) (strongunits.B, error) {
	if mock.GetMemoryBalloonTargetSizeFunc == nil {
		panic("MockVirtualMachine.GetMemoryBalloonTargetSizeFunc: method is nil but VirtualMachine.GetMemoryBalloonTargetSize was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetMemoryBalloonTargetSize.Lock()
	mock.calls.GetMemoryBalloonTargetSize = append(mock.calls.GetMemoryBalloonTargetSize, callInfo)
	mock.lockGetMemoryBalloonTargetSize.Unlock()
	return mock.GetMemoryBalloonTargetSizeFunc(ctx)
}

// GetMemoryBalloonTargetSizeCalls gets all the calls that were made to GetMemoryBalloonTargetSize.
// Check the length with:
//
//	len(mockedVirtualMachine.GetMemoryBalloonTargetSizeCalls())
func (mock *MockVirtualMachine) GetMemoryBalloonTargetSizeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetMemoryBalloonTargetSize.RLock()
	calls = mock.calls.GetMemoryBalloonTargetSize
	mock.lockGetMemoryBalloonTargetSize.RUnlock()
	return calls
}

// HardStop calls HardStopFunc.
func (mock *MockVirtualMachine) HardStop(ctx context.Context) error {
	if mock.HardStopFunc == nil {
		panic("MockVirtualMachine.HardStopFunc: method is nil but VirtualMachine.HardStop was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHardStop.Lock()
	mock.calls.HardStop = append(mock.calls.HardStop, callInfo)
	mock.lockHardStop.Unlock()
	return mock.HardStopFunc(ctx)
}

// HardStopCalls gets all the calls that were made to HardStop.
// Check the length with:
//
//	len(mockedVirtualMachine.HardStopCalls())
func (mock *MockVirtualMachine) HardStopCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHardStop.RLock()
	calls = mock.calls.HardStop
	mock.lockHardStop.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *MockVirtualMachine) ID() string {
	if mock.IDFunc == nil {
		panic("MockVirtualMachine.IDFunc: method is nil but VirtualMachine.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedVirtualMachine.IDCalls())
func (mock *MockVirtualMachine) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// Opts calls OptsFunc.
func (mock *MockVirtualMachine) Opts() *vmm.NewVMOptions {
	if mock.OptsFunc == nil {
		panic("MockVirtualMachine.OptsFunc: method is nil but VirtualMachine.Opts was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOpts.Lock()
	mock.calls.Opts = append(mock.calls.Opts, callInfo)
	mock.lockOpts.Unlock()
	return mock.OptsFunc()
}

// OptsCalls gets all the calls that were made to Opts.
// Check the length with:
//
//	len(mockedVirtualMachine.OptsCalls())
func (mock *MockVirtualMachine) OptsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOpts.RLock()
	calls = mock.calls.Opts
	mock.lockOpts.RUnlock()
	return calls
}

// Pause calls PauseFunc.
func (mock *MockVirtualMachine) Pause(ctx context.Context) error {
	if mock.PauseFunc == nil {
		panic("MockVirtualMachine.PauseFunc: method is nil but VirtualMachine.Pause was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPause.Lock()
	mock.calls.Pause = append(mock.calls.Pause, callInfo)
	mock.lockPause.Unlock()
	return mock.PauseFunc(ctx)
}

// PauseCalls gets all the calls that were made to Pause.
// Check the length with:
//
//	len(mockedVirtualMachine.PauseCalls())
func (mock *MockVirtualMachine) PauseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPause.RLock()
	calls = mock.calls.Pause
	mock.lockPause.RUnlock()
	return calls
}

// RequestStop calls RequestStopFunc.
func (mock *MockVirtualMachine) RequestStop(ctx context.Context) (bool, error) {
	if mock.RequestStopFunc == nil {
		panic("MockVirtualMachine.RequestStopFunc: method is nil but VirtualMachine.RequestStop was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRequestStop.Lock()
	mock.calls.RequestStop = append(mock.calls.RequestStop, callInfo)
	mock.lockRequestStop.Unlock()
	return mock.RequestStopFunc(ctx)
}

// RequestStopCalls gets all the calls that were made to RequestStop.
// Check the length with:
//
//	len(mockedVirtualMachine.RequestStopCalls())
func (mock *MockVirtualMachine) RequestStopCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRequestStop.RLock()
	calls = mock.calls.RequestStop
	mock.lockRequestStop.RUnlock()
	return calls
}

// RestoreFromFullSnapshot calls RestoreFromFullSnapshotFunc.
func (mock *MockVirtualMachine) RestoreFromFullSnapshot(ctx context.Context, path string) error {
	if mock.RestoreFromFullSnapshotFunc == nil {
		panic("MockVirtualMachine.RestoreFromFullSnapshotFunc: method is nil but VirtualMachine.RestoreFromFullSnapshot was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
	}{
		Ctx:  ctx,
		Path: path,
	}
	mock.lockRestoreFromFullSnapshot.Lock()
	mock.calls.RestoreFromFullSnapshot = append(mock.calls.RestoreFromFullSnapshot, callInfo)
	mock.lockRestoreFromFullSnapshot.Unlock()
	return mock.RestoreFromFullSnapshotFunc(ctx, path)
}

// RestoreFromFullSnapshotCalls gets all the calls that were made to RestoreFromFullSnapshot.
// Check the length with:
//
//	len(mockedVirtualMachine.RestoreFromFullSnapshotCalls())
func (mock *MockVirtualMachine) RestoreFromFullSnapshotCalls() []struct {
	Ctx  context.Context
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
	}
	mock.lockRestoreFromFullSnapshot.RLock()
	calls = mock.calls.RestoreFromFullSnapshot
	mock.lockRestoreFromFullSnapshot.RUnlock()
	return calls
}

// Resume calls ResumeFunc.
func (mock *MockVirtualMachine) Resume(ctx context.Context) error {
	if mock.ResumeFunc == nil {
		panic("MockVirtualMachine.ResumeFunc: method is nil but VirtualMachine.Resume was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockResume.Lock()
	mock.calls.Resume = append(mock.calls.Resume, callInfo)
	mock.lockResume.Unlock()
	return mock.ResumeFunc(ctx)
}

// ResumeCalls gets all the calls that were made to Resume.
// Check the length with:
//
//	len(mockedVirtualMachine.ResumeCalls())
func (mock *MockVirtualMachine) ResumeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockResume.RLock()
	calls = mock.calls.Resume
	mock.lockResume.RUnlock()
	return calls
}

// SaveFullSnapshot calls SaveFullSnapshotFunc.
func (mock *MockVirtualMachine) SaveFullSnapshot(ctx context.Context, path string) error {
	if mock.SaveFullSnapshotFunc == nil {
		panic("MockVirtualMachine.SaveFullSnapshotFunc: method is nil but VirtualMachine.SaveFullSnapshot was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
	}{
		Ctx:  ctx,
		Path: path,
	}
	mock.lockSaveFullSnapshot.Lock()
	mock.calls.SaveFullSnapshot = append(mock.calls.SaveFullSnapshot, callInfo)
	mock.lockSaveFullSnapshot.Unlock()
	return mock.SaveFullSnapshotFunc(ctx, path)
}

// SaveFullSnapshotCalls gets all the calls that were made to SaveFullSnapshot.
// Check the length with:
//
//	len(mockedVirtualMachine.SaveFullSnapshotCalls())
func (mock *MockVirtualMachine) SaveFullSnapshotCalls() []struct {
	Ctx  context.Context
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
	}
	mock.lockSaveFullSnapshot.RLock()
	calls = mock.calls.SaveFullSnapshot
	mock.lockSaveFullSnapshot.RUnlock()
	return calls
}

// ServeBackgroundTasks calls ServeBackgroundTasksFunc.
func (mock *MockVirtualMachine) ServeBackgroundTasks(ctx context.Context) error {
	if mock.ServeBackgroundTasksFunc == nil {
		panic("MockVirtualMachine.ServeBackgroundTasksFunc: method is nil but VirtualMachine.ServeBackgroundTasks was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockServeBackgroundTasks.Lock()
	mock.calls.ServeBackgroundTasks = append(mock.calls.ServeBackgroundTasks, callInfo)
	mock.lockServeBackgroundTasks.Unlock()
	return mock.ServeBackgroundTasksFunc(ctx)
}

// ServeBackgroundTasksCalls gets all the calls that were made to ServeBackgroundTasks.
// Check the length with:
//
//	len(mockedVirtualMachine.ServeBackgroundTasksCalls())
func (mock *MockVirtualMachine) ServeBackgroundTasksCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockServeBackgroundTasks.RLock()
	calls = mock.calls.ServeBackgroundTasks
	mock.lockServeBackgroundTasks.RUnlock()
	return calls
}

// SetMemoryBalloonTargetSize calls SetMemoryBalloonTargetSizeFunc.
func (mock *MockVirtualMachine) SetMemoryBalloonTargetSize(ctx context.Context, targetBytes strongunits.B) error {
	if mock.SetMemoryBalloonTargetSizeFunc == nil {
		panic("MockVirtualMachine.SetMemoryBalloonTargetSizeFunc: method is nil but VirtualMachine.SetMemoryBalloonTargetSize was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		TargetBytes strongunits.B
	}{
		Ctx:         ctx,
		TargetBytes: targetBytes,
	}
	mock.lockSetMemoryBalloonTargetSize.Lock()
	mock.calls.SetMemoryBalloonTargetSize = append(mock.calls.SetMemoryBalloonTargetSize, callInfo)
	mock.lockSetMemoryBalloonTargetSize.Unlock()
	return mock.SetMemoryBalloonTargetSizeFunc(ctx, targetBytes)
}

// SetMemoryBalloonTargetSizeCalls gets all the calls that were made to SetMemoryBalloonTargetSize.
// Check the length with:
//
//	len(mockedVirtualMachine.SetMemoryBalloonTargetSizeCalls())
func (mock *MockVirtualMachine) SetMemoryBalloonTargetSizeCalls() []struct {
	Ctx         context.Context
	TargetBytes strongunits.B
} {
	var calls []struct {
		Ctx         context.Context
		TargetBytes strongunits.B
	}
	mock.lockSetMemoryBalloonTargetSize.RLock()
	calls = mock.calls.SetMemoryBalloonTargetSize
	mock.lockSetMemoryBalloonTargetSize.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *MockVirtualMachine) Start(ctx context.Context) error {
	if mock.StartFunc == nil {
		panic("MockVirtualMachine.StartFunc: method is nil but VirtualMachine.Start was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedVirtualMachine.StartCalls())
func (mock *MockVirtualMachine) StartCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// StartGraphicApplication calls StartGraphicApplicationFunc.
func (mock *MockVirtualMachine) StartGraphicApplication(width float64, height float64) error {
	if mock.StartGraphicApplicationFunc == nil {
		panic("MockVirtualMachine.StartGraphicApplicationFunc: method is nil but VirtualMachine.StartGraphicApplication was just called")
	}
	callInfo := struct {
		Width  float64
		Height float64
	}{
		Width:  width,
		Height: height,
	}
	mock.lockStartGraphicApplication.Lock()
	mock.calls.StartGraphicApplication = append(mock.calls.StartGraphicApplication, callInfo)
	mock.lockStartGraphicApplication.Unlock()
	return mock.StartGraphicApplicationFunc(width, height)
}

// StartGraphicApplicationCalls gets all the calls that were made to StartGraphicApplication.
// Check the length with:
//
//	len(mockedVirtualMachine.StartGraphicApplicationCalls())
func (mock *MockVirtualMachine) StartGraphicApplicationCalls() []struct {
	Width  float64
	Height float64
} {
	var calls []struct {
		Width  float64
		Height float64
	}
	mock.lockStartGraphicApplication.RLock()
	calls = mock.calls.StartGraphicApplication
	mock.lockStartGraphicApplication.RUnlock()
	return calls
}

// StateChangeNotify calls StateChangeNotifyFunc.
func (mock *MockVirtualMachine) StateChangeNotify(ctx context.Context) <-chan vmm.VirtualMachineStateChange {
	if mock.StateChangeNotifyFunc == nil {
		panic("MockVirtualMachine.StateChangeNotifyFunc: method is nil but VirtualMachine.StateChangeNotify was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockStateChangeNotify.Lock()
	mock.calls.StateChangeNotify = append(mock.calls.StateChangeNotify, callInfo)
	mock.lockStateChangeNotify.Unlock()
	return mock.StateChangeNotifyFunc(ctx)
}

// StateChangeNotifyCalls gets all the calls that were made to StateChangeNotify.
// Check the length with:
//
//	len(mockedVirtualMachine.StateChangeNotifyCalls())
func (mock *MockVirtualMachine) StateChangeNotifyCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockStateChangeNotify.RLock()
	calls = mock.calls.StateChangeNotify
	mock.lockStateChangeNotify.RUnlock()
	return calls
}

// VSockConnect calls VSockConnectFunc.
func (mock *MockVirtualMachine) VSockConnect(ctx context.Context, port uint32) (net.Conn, error) {
	if mock.VSockConnectFunc == nil {
		panic("MockVirtualMachine.VSockConnectFunc: method is nil but VirtualMachine.VSockConnect was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Port uint32
	}{
		Ctx:  ctx,
		Port: port,
	}
	mock.lockVSockConnect.Lock()
	mock.calls.VSockConnect = append(mock.calls.VSockConnect, callInfo)
	mock.lockVSockConnect.Unlock()
	return mock.VSockConnectFunc(ctx, port)
}

// VSockConnectCalls gets all the calls that were made to VSockConnect.
// Check the length with:
//
//	len(mockedVirtualMachine.VSockConnectCalls())
func (mock *MockVirtualMachine) VSockConnectCalls() []struct {
	Ctx  context.Context
	Port uint32
} {
	var calls []struct {
		Ctx  context.Context
		Port uint32
	}
	mock.lockVSockConnect.RLock()
	calls = mock.calls.VSockConnect
	mock.lockVSockConnect.RUnlock()
	return calls
}

// VSockListen calls VSockListenFunc.
func (mock *MockVirtualMachine) VSockListen(ctx context.Context, port uint32) (net.Listener, error) {
	if mock.VSockListenFunc == nil {
		panic("MockVirtualMachine.VSockListenFunc: method is nil but VirtualMachine.VSockListen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Port uint32
	}{
		Ctx:  ctx,
		Port: port,
	}
	mock.lockVSockListen.Lock()
	mock.calls.VSockListen = append(mock.calls.VSockListen, callInfo)
	mock.lockVSockListen.Unlock()
	return mock.VSockListenFunc(ctx, port)
}

// VSockListenCalls gets all the calls that were made to VSockListen.
// Check the length with:
//
//	len(mockedVirtualMachine.VSockListenCalls())
func (mock *MockVirtualMachine) VSockListenCalls() []struct {
	Ctx  context.Context
	Port uint32
} {
	var calls []struct {
		Ctx  context.Context
		Port uint32
	}
	mock.lockVSockListen.RLock()
	calls = mock.calls.VSockListen
	mock.lockVSockListen.RUnlock()
	return calls
}
