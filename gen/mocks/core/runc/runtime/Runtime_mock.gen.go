// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockruntime

import (
	"context"
	"sync"

	"github.com/containerd/go-runc"
	"github.com/opencontainers/runtime-spec/specs-go"
	"github.com/walteh/runm/core/runc/runtime"
)

// Ensure that MockRuntime does implement runtime.Runtime.
// If this is not the case, regenerate this file with mockery.
var _ runtime.Runtime = &MockRuntime{}

// MockRuntime is a mock implementation of runtime.Runtime.
//
//	func TestSomethingThatUsesRuntime(t *testing.T) {
//
//		// make and configure a mocked runtime.Runtime
//		mockedRuntime := &MockRuntime{
//			CheckpointFunc: func(ctx context.Context, id string, opts *runc.CheckpointOpts, actions ...runc.CheckpointAction) error {
//				panic("mock out the Checkpoint method")
//			},
//			CreateFunc: func(ctx context.Context, id string, bundle string, opts *runc.CreateOpts) error {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, id string, opts *runc.DeleteOpts) error {
//				panic("mock out the Delete method")
//			},
//			ExecFunc: func(ctx context.Context, id string, spec specs.Process, opts *runc.ExecOpts) error {
//				panic("mock out the Exec method")
//			},
//			KillFunc: func(ctx context.Context, id string, signal int, opts *runc.KillOpts) error {
//				panic("mock out the Kill method")
//			},
//			NewNullIOFunc: func() (runtime.IO, error) {
//				panic("mock out the NewNullIO method")
//			},
//			NewPipeIOFunc: func(ctx context.Context, cioUID int, ioGID int, opts ...runc.IOOpt) (runtime.IO, error) {
//				panic("mock out the NewPipeIO method")
//			},
//			NewTempConsoleSocketFunc: func(ctx context.Context) (runtime.ConsoleSocket, error) {
//				panic("mock out the NewTempConsoleSocket method")
//			},
//			PauseFunc: func(ctx context.Context, id string) error {
//				panic("mock out the Pause method")
//			},
//			PsFunc: func(ctx context.Context, id string) ([]int, error) {
//				panic("mock out the Ps method")
//			},
//			ReadPidFileFunc: func(ctx context.Context, path string) (int, error) {
//				panic("mock out the ReadPidFile method")
//			},
//			RestoreFunc: func(ctx context.Context, id string, bundle string, opts *runc.RestoreOpts) (int, error) {
//				panic("mock out the Restore method")
//			},
//			ResumeFunc: func(ctx context.Context, id string) error {
//				panic("mock out the Resume method")
//			},
//			SharedDirFunc: func() string {
//				panic("mock out the SharedDir method")
//			},
//			StartFunc: func(ctx context.Context, id string) error {
//				panic("mock out the Start method")
//			},
//			UpdateFunc: func(ctx context.Context, id string, resources *specs.LinuxResources) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedRuntime in code that requires runtime.Runtime
//		// and then make assertions.
//
//	}
type MockRuntime struct {
	// CheckpointFunc mocks the Checkpoint method.
	CheckpointFunc func(ctx context.Context, id string, opts *runc.CheckpointOpts, actions ...runc.CheckpointAction) error

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, id string, bundle string, opts *runc.CreateOpts) error

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id string, opts *runc.DeleteOpts) error

	// ExecFunc mocks the Exec method.
	ExecFunc func(ctx context.Context, id string, spec specs.Process, opts *runc.ExecOpts) error

	// KillFunc mocks the Kill method.
	KillFunc func(ctx context.Context, id string, signal int, opts *runc.KillOpts) error

	// NewNullIOFunc mocks the NewNullIO method.
	NewNullIOFunc func() (runtime.IO, error)

	// NewPipeIOFunc mocks the NewPipeIO method.
	NewPipeIOFunc func(ctx context.Context, cioUID int, ioGID int, opts ...runc.IOOpt) (runtime.IO, error)

	// NewTempConsoleSocketFunc mocks the NewTempConsoleSocket method.
	NewTempConsoleSocketFunc func(ctx context.Context) (runtime.ConsoleSocket, error)

	// PauseFunc mocks the Pause method.
	PauseFunc func(ctx context.Context, id string) error

	// PsFunc mocks the Ps method.
	PsFunc func(ctx context.Context, id string) ([]int, error)

	// ReadPidFileFunc mocks the ReadPidFile method.
	ReadPidFileFunc func(ctx context.Context, path string) (int, error)

	// RestoreFunc mocks the Restore method.
	RestoreFunc func(ctx context.Context, id string, bundle string, opts *runc.RestoreOpts) (int, error)

	// ResumeFunc mocks the Resume method.
	ResumeFunc func(ctx context.Context, id string) error

	// SharedDirFunc mocks the SharedDir method.
	SharedDirFunc func() string

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, id string) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, id string, resources *specs.LinuxResources) error

	// calls tracks calls to the methods.
	calls struct {
		// Checkpoint holds details about calls to the Checkpoint method.
		Checkpoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Opts is the opts argument value.
			Opts *runc.CheckpointOpts
			// Actions is the actions argument value.
			Actions []runc.CheckpointAction
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Bundle is the bundle argument value.
			Bundle string
			// Opts is the opts argument value.
			Opts *runc.CreateOpts
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Opts is the opts argument value.
			Opts *runc.DeleteOpts
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Spec is the spec argument value.
			Spec specs.Process
			// Opts is the opts argument value.
			Opts *runc.ExecOpts
		}
		// Kill holds details about calls to the Kill method.
		Kill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Signal is the signal argument value.
			Signal int
			// Opts is the opts argument value.
			Opts *runc.KillOpts
		}
		// NewNullIO holds details about calls to the NewNullIO method.
		NewNullIO []struct {
		}
		// NewPipeIO holds details about calls to the NewPipeIO method.
		NewPipeIO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CioUID is the cioUID argument value.
			CioUID int
			// IoGID is the ioGID argument value.
			IoGID int
			// Opts is the opts argument value.
			Opts []runc.IOOpt
		}
		// NewTempConsoleSocket holds details about calls to the NewTempConsoleSocket method.
		NewTempConsoleSocket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Pause holds details about calls to the Pause method.
		Pause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// Ps holds details about calls to the Ps method.
		Ps []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// ReadPidFile holds details about calls to the ReadPidFile method.
		ReadPidFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
		}
		// Restore holds details about calls to the Restore method.
		Restore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Bundle is the bundle argument value.
			Bundle string
			// Opts is the opts argument value.
			Opts *runc.RestoreOpts
		}
		// Resume holds details about calls to the Resume method.
		Resume []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// SharedDir holds details about calls to the SharedDir method.
		SharedDir []struct {
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Resources is the resources argument value.
			Resources *specs.LinuxResources
		}
	}
	lockCheckpoint           sync.RWMutex
	lockCreate               sync.RWMutex
	lockDelete               sync.RWMutex
	lockExec                 sync.RWMutex
	lockKill                 sync.RWMutex
	lockNewNullIO            sync.RWMutex
	lockNewPipeIO            sync.RWMutex
	lockNewTempConsoleSocket sync.RWMutex
	lockPause                sync.RWMutex
	lockPs                   sync.RWMutex
	lockReadPidFile          sync.RWMutex
	lockRestore              sync.RWMutex
	lockResume               sync.RWMutex
	lockSharedDir            sync.RWMutex
	lockStart                sync.RWMutex
	lockUpdate               sync.RWMutex
}

// Checkpoint calls CheckpointFunc.
func (mock *MockRuntime) Checkpoint(ctx context.Context, id string, opts *runc.CheckpointOpts, actions ...runc.CheckpointAction) error {
	if mock.CheckpointFunc == nil {
		panic("MockRuntime.CheckpointFunc: method is nil but Runtime.Checkpoint was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ID      string
		Opts    *runc.CheckpointOpts
		Actions []runc.CheckpointAction
	}{
		Ctx:     ctx,
		ID:      id,
		Opts:    opts,
		Actions: actions,
	}
	mock.lockCheckpoint.Lock()
	mock.calls.Checkpoint = append(mock.calls.Checkpoint, callInfo)
	mock.lockCheckpoint.Unlock()
	return mock.CheckpointFunc(ctx, id, opts, actions...)
}

// CheckpointCalls gets all the calls that were made to Checkpoint.
// Check the length with:
//
//	len(mockedRuntime.CheckpointCalls())
func (mock *MockRuntime) CheckpointCalls() []struct {
	Ctx     context.Context
	ID      string
	Opts    *runc.CheckpointOpts
	Actions []runc.CheckpointAction
} {
	var calls []struct {
		Ctx     context.Context
		ID      string
		Opts    *runc.CheckpointOpts
		Actions []runc.CheckpointAction
	}
	mock.lockCheckpoint.RLock()
	calls = mock.calls.Checkpoint
	mock.lockCheckpoint.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *MockRuntime) Create(ctx context.Context, id string, bundle string, opts *runc.CreateOpts) error {
	if mock.CreateFunc == nil {
		panic("MockRuntime.CreateFunc: method is nil but Runtime.Create was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     string
		Bundle string
		Opts   *runc.CreateOpts
	}{
		Ctx:    ctx,
		ID:     id,
		Bundle: bundle,
		Opts:   opts,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, id, bundle, opts)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedRuntime.CreateCalls())
func (mock *MockRuntime) CreateCalls() []struct {
	Ctx    context.Context
	ID     string
	Bundle string
	Opts   *runc.CreateOpts
} {
	var calls []struct {
		Ctx    context.Context
		ID     string
		Bundle string
		Opts   *runc.CreateOpts
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *MockRuntime) Delete(ctx context.Context, id string, opts *runc.DeleteOpts) error {
	if mock.DeleteFunc == nil {
		panic("MockRuntime.DeleteFunc: method is nil but Runtime.Delete was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		ID   string
		Opts *runc.DeleteOpts
	}{
		Ctx:  ctx,
		ID:   id,
		Opts: opts,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id, opts)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedRuntime.DeleteCalls())
func (mock *MockRuntime) DeleteCalls() []struct {
	Ctx  context.Context
	ID   string
	Opts *runc.DeleteOpts
} {
	var calls []struct {
		Ctx  context.Context
		ID   string
		Opts *runc.DeleteOpts
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *MockRuntime) Exec(ctx context.Context, id string, spec specs.Process, opts *runc.ExecOpts) error {
	if mock.ExecFunc == nil {
		panic("MockRuntime.ExecFunc: method is nil but Runtime.Exec was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		ID   string
		Spec specs.Process
		Opts *runc.ExecOpts
	}{
		Ctx:  ctx,
		ID:   id,
		Spec: spec,
		Opts: opts,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(ctx, id, spec, opts)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedRuntime.ExecCalls())
func (mock *MockRuntime) ExecCalls() []struct {
	Ctx  context.Context
	ID   string
	Spec specs.Process
	Opts *runc.ExecOpts
} {
	var calls []struct {
		Ctx  context.Context
		ID   string
		Spec specs.Process
		Opts *runc.ExecOpts
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// Kill calls KillFunc.
func (mock *MockRuntime) Kill(ctx context.Context, id string, signal int, opts *runc.KillOpts) error {
	if mock.KillFunc == nil {
		panic("MockRuntime.KillFunc: method is nil but Runtime.Kill was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     string
		Signal int
		Opts   *runc.KillOpts
	}{
		Ctx:    ctx,
		ID:     id,
		Signal: signal,
		Opts:   opts,
	}
	mock.lockKill.Lock()
	mock.calls.Kill = append(mock.calls.Kill, callInfo)
	mock.lockKill.Unlock()
	return mock.KillFunc(ctx, id, signal, opts)
}

// KillCalls gets all the calls that were made to Kill.
// Check the length with:
//
//	len(mockedRuntime.KillCalls())
func (mock *MockRuntime) KillCalls() []struct {
	Ctx    context.Context
	ID     string
	Signal int
	Opts   *runc.KillOpts
} {
	var calls []struct {
		Ctx    context.Context
		ID     string
		Signal int
		Opts   *runc.KillOpts
	}
	mock.lockKill.RLock()
	calls = mock.calls.Kill
	mock.lockKill.RUnlock()
	return calls
}

// NewNullIO calls NewNullIOFunc.
func (mock *MockRuntime) NewNullIO() (runtime.IO, error) {
	if mock.NewNullIOFunc == nil {
		panic("MockRuntime.NewNullIOFunc: method is nil but Runtime.NewNullIO was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNewNullIO.Lock()
	mock.calls.NewNullIO = append(mock.calls.NewNullIO, callInfo)
	mock.lockNewNullIO.Unlock()
	return mock.NewNullIOFunc()
}

// NewNullIOCalls gets all the calls that were made to NewNullIO.
// Check the length with:
//
//	len(mockedRuntime.NewNullIOCalls())
func (mock *MockRuntime) NewNullIOCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNewNullIO.RLock()
	calls = mock.calls.NewNullIO
	mock.lockNewNullIO.RUnlock()
	return calls
}

// NewPipeIO calls NewPipeIOFunc.
func (mock *MockRuntime) NewPipeIO(ctx context.Context, cioUID int, ioGID int, opts ...runc.IOOpt) (runtime.IO, error) {
	if mock.NewPipeIOFunc == nil {
		panic("MockRuntime.NewPipeIOFunc: method is nil but Runtime.NewPipeIO was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		CioUID int
		IoGID  int
		Opts   []runc.IOOpt
	}{
		Ctx:    ctx,
		CioUID: cioUID,
		IoGID:  ioGID,
		Opts:   opts,
	}
	mock.lockNewPipeIO.Lock()
	mock.calls.NewPipeIO = append(mock.calls.NewPipeIO, callInfo)
	mock.lockNewPipeIO.Unlock()
	return mock.NewPipeIOFunc(ctx, cioUID, ioGID, opts...)
}

// NewPipeIOCalls gets all the calls that were made to NewPipeIO.
// Check the length with:
//
//	len(mockedRuntime.NewPipeIOCalls())
func (mock *MockRuntime) NewPipeIOCalls() []struct {
	Ctx    context.Context
	CioUID int
	IoGID  int
	Opts   []runc.IOOpt
} {
	var calls []struct {
		Ctx    context.Context
		CioUID int
		IoGID  int
		Opts   []runc.IOOpt
	}
	mock.lockNewPipeIO.RLock()
	calls = mock.calls.NewPipeIO
	mock.lockNewPipeIO.RUnlock()
	return calls
}

// NewTempConsoleSocket calls NewTempConsoleSocketFunc.
func (mock *MockRuntime) NewTempConsoleSocket(ctx context.Context) (runtime.ConsoleSocket, error) {
	if mock.NewTempConsoleSocketFunc == nil {
		panic("MockRuntime.NewTempConsoleSocketFunc: method is nil but Runtime.NewTempConsoleSocket was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockNewTempConsoleSocket.Lock()
	mock.calls.NewTempConsoleSocket = append(mock.calls.NewTempConsoleSocket, callInfo)
	mock.lockNewTempConsoleSocket.Unlock()
	return mock.NewTempConsoleSocketFunc(ctx)
}

// NewTempConsoleSocketCalls gets all the calls that were made to NewTempConsoleSocket.
// Check the length with:
//
//	len(mockedRuntime.NewTempConsoleSocketCalls())
func (mock *MockRuntime) NewTempConsoleSocketCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockNewTempConsoleSocket.RLock()
	calls = mock.calls.NewTempConsoleSocket
	mock.lockNewTempConsoleSocket.RUnlock()
	return calls
}

// Pause calls PauseFunc.
func (mock *MockRuntime) Pause(ctx context.Context, id string) error {
	if mock.PauseFunc == nil {
		panic("MockRuntime.PauseFunc: method is nil but Runtime.Pause was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockPause.Lock()
	mock.calls.Pause = append(mock.calls.Pause, callInfo)
	mock.lockPause.Unlock()
	return mock.PauseFunc(ctx, id)
}

// PauseCalls gets all the calls that were made to Pause.
// Check the length with:
//
//	len(mockedRuntime.PauseCalls())
func (mock *MockRuntime) PauseCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockPause.RLock()
	calls = mock.calls.Pause
	mock.lockPause.RUnlock()
	return calls
}

// Ps calls PsFunc.
func (mock *MockRuntime) Ps(ctx context.Context, id string) ([]int, error) {
	if mock.PsFunc == nil {
		panic("MockRuntime.PsFunc: method is nil but Runtime.Ps was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockPs.Lock()
	mock.calls.Ps = append(mock.calls.Ps, callInfo)
	mock.lockPs.Unlock()
	return mock.PsFunc(ctx, id)
}

// PsCalls gets all the calls that were made to Ps.
// Check the length with:
//
//	len(mockedRuntime.PsCalls())
func (mock *MockRuntime) PsCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockPs.RLock()
	calls = mock.calls.Ps
	mock.lockPs.RUnlock()
	return calls
}

// ReadPidFile calls ReadPidFileFunc.
func (mock *MockRuntime) ReadPidFile(ctx context.Context, path string) (int, error) {
	if mock.ReadPidFileFunc == nil {
		panic("MockRuntime.ReadPidFileFunc: method is nil but Runtime.ReadPidFile was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
	}{
		Ctx:  ctx,
		Path: path,
	}
	mock.lockReadPidFile.Lock()
	mock.calls.ReadPidFile = append(mock.calls.ReadPidFile, callInfo)
	mock.lockReadPidFile.Unlock()
	return mock.ReadPidFileFunc(ctx, path)
}

// ReadPidFileCalls gets all the calls that were made to ReadPidFile.
// Check the length with:
//
//	len(mockedRuntime.ReadPidFileCalls())
func (mock *MockRuntime) ReadPidFileCalls() []struct {
	Ctx  context.Context
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
	}
	mock.lockReadPidFile.RLock()
	calls = mock.calls.ReadPidFile
	mock.lockReadPidFile.RUnlock()
	return calls
}

// Restore calls RestoreFunc.
func (mock *MockRuntime) Restore(ctx context.Context, id string, bundle string, opts *runc.RestoreOpts) (int, error) {
	if mock.RestoreFunc == nil {
		panic("MockRuntime.RestoreFunc: method is nil but Runtime.Restore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     string
		Bundle string
		Opts   *runc.RestoreOpts
	}{
		Ctx:    ctx,
		ID:     id,
		Bundle: bundle,
		Opts:   opts,
	}
	mock.lockRestore.Lock()
	mock.calls.Restore = append(mock.calls.Restore, callInfo)
	mock.lockRestore.Unlock()
	return mock.RestoreFunc(ctx, id, bundle, opts)
}

// RestoreCalls gets all the calls that were made to Restore.
// Check the length with:
//
//	len(mockedRuntime.RestoreCalls())
func (mock *MockRuntime) RestoreCalls() []struct {
	Ctx    context.Context
	ID     string
	Bundle string
	Opts   *runc.RestoreOpts
} {
	var calls []struct {
		Ctx    context.Context
		ID     string
		Bundle string
		Opts   *runc.RestoreOpts
	}
	mock.lockRestore.RLock()
	calls = mock.calls.Restore
	mock.lockRestore.RUnlock()
	return calls
}

// Resume calls ResumeFunc.
func (mock *MockRuntime) Resume(ctx context.Context, id string) error {
	if mock.ResumeFunc == nil {
		panic("MockRuntime.ResumeFunc: method is nil but Runtime.Resume was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockResume.Lock()
	mock.calls.Resume = append(mock.calls.Resume, callInfo)
	mock.lockResume.Unlock()
	return mock.ResumeFunc(ctx, id)
}

// ResumeCalls gets all the calls that were made to Resume.
// Check the length with:
//
//	len(mockedRuntime.ResumeCalls())
func (mock *MockRuntime) ResumeCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockResume.RLock()
	calls = mock.calls.Resume
	mock.lockResume.RUnlock()
	return calls
}

// SharedDir calls SharedDirFunc.
func (mock *MockRuntime) SharedDir() string {
	if mock.SharedDirFunc == nil {
		panic("MockRuntime.SharedDirFunc: method is nil but Runtime.SharedDir was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSharedDir.Lock()
	mock.calls.SharedDir = append(mock.calls.SharedDir, callInfo)
	mock.lockSharedDir.Unlock()
	return mock.SharedDirFunc()
}

// SharedDirCalls gets all the calls that were made to SharedDir.
// Check the length with:
//
//	len(mockedRuntime.SharedDirCalls())
func (mock *MockRuntime) SharedDirCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSharedDir.RLock()
	calls = mock.calls.SharedDir
	mock.lockSharedDir.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *MockRuntime) Start(ctx context.Context, id string) error {
	if mock.StartFunc == nil {
		panic("MockRuntime.StartFunc: method is nil but Runtime.Start was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, id)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedRuntime.StartCalls())
func (mock *MockRuntime) StartCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MockRuntime) Update(ctx context.Context, id string, resources *specs.LinuxResources) error {
	if mock.UpdateFunc == nil {
		panic("MockRuntime.UpdateFunc: method is nil but Runtime.Update was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ID        string
		Resources *specs.LinuxResources
	}{
		Ctx:       ctx,
		ID:        id,
		Resources: resources,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, id, resources)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedRuntime.UpdateCalls())
func (mock *MockRuntime) UpdateCalls() []struct {
	Ctx       context.Context
	ID        string
	Resources *specs.LinuxResources
} {
	var calls []struct {
		Ctx       context.Context
		ID        string
		Resources *specs.LinuxResources
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
