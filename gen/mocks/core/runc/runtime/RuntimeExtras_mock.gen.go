// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockruntime

import (
	"context"
	"sync"
	"time"

	"github.com/containerd/go-runc"
	"github.com/walteh/runm/core/runc/runtime"
)

// Ensure that MockRuntimeExtras does implement runtime.RuntimeExtras.
// If this is not the case, regenerate this file with mockery.
var _ runtime.RuntimeExtras = &MockRuntimeExtras{}

// MockRuntimeExtras is a mock implementation of runtime.RuntimeExtras.
//
//	func TestSomethingThatUsesRuntimeExtras(t *testing.T) {
//
//		// make and configure a mocked runtime.RuntimeExtras
//		mockedRuntimeExtras := &MockRuntimeExtras{
//			EventsFunc: func(context1 context.Context, s string, duration time.Duration) (chan *runc.Event, error) {
//				panic("mock out the Events method")
//			},
//			ListFunc: func(context1 context.Context) ([]*runc.Container, error) {
//				panic("mock out the List method")
//			},
//			RunFunc: func(context1 context.Context, s string, s1 string, createOpts *runc.CreateOpts) (int, error) {
//				panic("mock out the Run method")
//			},
//			StateFunc: func(context1 context.Context, s string) (*runc.Container, error) {
//				panic("mock out the State method")
//			},
//			StatsFunc: func(context1 context.Context, s string) (*runc.Stats, error) {
//				panic("mock out the Stats method")
//			},
//			TopFunc: func(context1 context.Context, s string, s1 string) (*runc.TopResults, error) {
//				panic("mock out the Top method")
//			},
//			VersionFunc: func(context1 context.Context) (runc.Version, error) {
//				panic("mock out the Version method")
//			},
//		}
//
//		// use mockedRuntimeExtras in code that requires runtime.RuntimeExtras
//		// and then make assertions.
//
//	}
type MockRuntimeExtras struct {
	// EventsFunc mocks the Events method.
	EventsFunc func(context1 context.Context, s string, duration time.Duration) (chan *runc.Event, error)

	// ListFunc mocks the List method.
	ListFunc func(context1 context.Context) ([]*runc.Container, error)

	// RunFunc mocks the Run method.
	RunFunc func(context1 context.Context, s string, s1 string, createOpts *runc.CreateOpts) (int, error)

	// StateFunc mocks the State method.
	StateFunc func(context1 context.Context, s string) (*runc.Container, error)

	// StatsFunc mocks the Stats method.
	StatsFunc func(context1 context.Context, s string) (*runc.Stats, error)

	// TopFunc mocks the Top method.
	TopFunc func(context1 context.Context, s string, s1 string) (*runc.TopResults, error)

	// VersionFunc mocks the Version method.
	VersionFunc func(context1 context.Context) (runc.Version, error)

	// calls tracks calls to the methods.
	calls struct {
		// Events holds details about calls to the Events method.
		Events []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// S is the s argument value.
			S string
			// Duration is the duration argument value.
			Duration time.Duration
		}
		// List holds details about calls to the List method.
		List []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// S is the s argument value.
			S string
			// S1 is the s1 argument value.
			S1 string
			// CreateOpts is the createOpts argument value.
			CreateOpts *runc.CreateOpts
		}
		// State holds details about calls to the State method.
		State []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// S is the s argument value.
			S string
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// S is the s argument value.
			S string
		}
		// Top holds details about calls to the Top method.
		Top []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// S is the s argument value.
			S string
			// S1 is the s1 argument value.
			S1 string
		}
		// Version holds details about calls to the Version method.
		Version []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
		}
	}
	lockEvents  sync.RWMutex
	lockList    sync.RWMutex
	lockRun     sync.RWMutex
	lockState   sync.RWMutex
	lockStats   sync.RWMutex
	lockTop     sync.RWMutex
	lockVersion sync.RWMutex
}

// Events calls EventsFunc.
func (mock *MockRuntimeExtras) Events(context1 context.Context, s string, duration time.Duration) (chan *runc.Event, error) {
	if mock.EventsFunc == nil {
		panic("MockRuntimeExtras.EventsFunc: method is nil but RuntimeExtras.Events was just called")
	}
	callInfo := struct {
		Context1 context.Context
		S        string
		Duration time.Duration
	}{
		Context1: context1,
		S:        s,
		Duration: duration,
	}
	mock.lockEvents.Lock()
	mock.calls.Events = append(mock.calls.Events, callInfo)
	mock.lockEvents.Unlock()
	return mock.EventsFunc(context1, s, duration)
}

// EventsCalls gets all the calls that were made to Events.
// Check the length with:
//
//	len(mockedRuntimeExtras.EventsCalls())
func (mock *MockRuntimeExtras) EventsCalls() []struct {
	Context1 context.Context
	S        string
	Duration time.Duration
} {
	var calls []struct {
		Context1 context.Context
		S        string
		Duration time.Duration
	}
	mock.lockEvents.RLock()
	calls = mock.calls.Events
	mock.lockEvents.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *MockRuntimeExtras) List(context1 context.Context) ([]*runc.Container, error) {
	if mock.ListFunc == nil {
		panic("MockRuntimeExtras.ListFunc: method is nil but RuntimeExtras.List was just called")
	}
	callInfo := struct {
		Context1 context.Context
	}{
		Context1: context1,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(context1)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedRuntimeExtras.ListCalls())
func (mock *MockRuntimeExtras) ListCalls() []struct {
	Context1 context.Context
} {
	var calls []struct {
		Context1 context.Context
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *MockRuntimeExtras) Run(context1 context.Context, s string, s1 string, createOpts *runc.CreateOpts) (int, error) {
	if mock.RunFunc == nil {
		panic("MockRuntimeExtras.RunFunc: method is nil but RuntimeExtras.Run was just called")
	}
	callInfo := struct {
		Context1   context.Context
		S          string
		S1         string
		CreateOpts *runc.CreateOpts
	}{
		Context1:   context1,
		S:          s,
		S1:         s1,
		CreateOpts: createOpts,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(context1, s, s1, createOpts)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedRuntimeExtras.RunCalls())
func (mock *MockRuntimeExtras) RunCalls() []struct {
	Context1   context.Context
	S          string
	S1         string
	CreateOpts *runc.CreateOpts
} {
	var calls []struct {
		Context1   context.Context
		S          string
		S1         string
		CreateOpts *runc.CreateOpts
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// State calls StateFunc.
func (mock *MockRuntimeExtras) State(context1 context.Context, s string) (*runc.Container, error) {
	if mock.StateFunc == nil {
		panic("MockRuntimeExtras.StateFunc: method is nil but RuntimeExtras.State was just called")
	}
	callInfo := struct {
		Context1 context.Context
		S        string
	}{
		Context1: context1,
		S:        s,
	}
	mock.lockState.Lock()
	mock.calls.State = append(mock.calls.State, callInfo)
	mock.lockState.Unlock()
	return mock.StateFunc(context1, s)
}

// StateCalls gets all the calls that were made to State.
// Check the length with:
//
//	len(mockedRuntimeExtras.StateCalls())
func (mock *MockRuntimeExtras) StateCalls() []struct {
	Context1 context.Context
	S        string
} {
	var calls []struct {
		Context1 context.Context
		S        string
	}
	mock.lockState.RLock()
	calls = mock.calls.State
	mock.lockState.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *MockRuntimeExtras) Stats(context1 context.Context, s string) (*runc.Stats, error) {
	if mock.StatsFunc == nil {
		panic("MockRuntimeExtras.StatsFunc: method is nil but RuntimeExtras.Stats was just called")
	}
	callInfo := struct {
		Context1 context.Context
		S        string
	}{
		Context1: context1,
		S:        s,
	}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	return mock.StatsFunc(context1, s)
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedRuntimeExtras.StatsCalls())
func (mock *MockRuntimeExtras) StatsCalls() []struct {
	Context1 context.Context
	S        string
} {
	var calls []struct {
		Context1 context.Context
		S        string
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// Top calls TopFunc.
func (mock *MockRuntimeExtras) Top(context1 context.Context, s string, s1 string) (*runc.TopResults, error) {
	if mock.TopFunc == nil {
		panic("MockRuntimeExtras.TopFunc: method is nil but RuntimeExtras.Top was just called")
	}
	callInfo := struct {
		Context1 context.Context
		S        string
		S1       string
	}{
		Context1: context1,
		S:        s,
		S1:       s1,
	}
	mock.lockTop.Lock()
	mock.calls.Top = append(mock.calls.Top, callInfo)
	mock.lockTop.Unlock()
	return mock.TopFunc(context1, s, s1)
}

// TopCalls gets all the calls that were made to Top.
// Check the length with:
//
//	len(mockedRuntimeExtras.TopCalls())
func (mock *MockRuntimeExtras) TopCalls() []struct {
	Context1 context.Context
	S        string
	S1       string
} {
	var calls []struct {
		Context1 context.Context
		S        string
		S1       string
	}
	mock.lockTop.RLock()
	calls = mock.calls.Top
	mock.lockTop.RUnlock()
	return calls
}

// Version calls VersionFunc.
func (mock *MockRuntimeExtras) Version(context1 context.Context) (runc.Version, error) {
	if mock.VersionFunc == nil {
		panic("MockRuntimeExtras.VersionFunc: method is nil but RuntimeExtras.Version was just called")
	}
	callInfo := struct {
		Context1 context.Context
	}{
		Context1: context1,
	}
	mock.lockVersion.Lock()
	mock.calls.Version = append(mock.calls.Version, callInfo)
	mock.lockVersion.Unlock()
	return mock.VersionFunc(context1)
}

// VersionCalls gets all the calls that were made to Version.
// Check the length with:
//
//	len(mockedRuntimeExtras.VersionCalls())
func (mock *MockRuntimeExtras) VersionCalls() []struct {
	Context1 context.Context
} {
	var calls []struct {
		Context1 context.Context
	}
	mock.lockVersion.RLock()
	calls = mock.calls.Version
	mock.lockVersion.RUnlock()
	return calls
}
