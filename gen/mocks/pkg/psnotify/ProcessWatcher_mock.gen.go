// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockpsnotify

import (
	"sync"

	"github.com/walteh/runm/pkg/psnotify"
)

// Ensure that MockProcessWatcher does implement psnotify.ProcessWatcher.
// If this is not the case, regenerate this file with mockery.
var _ psnotify.ProcessWatcher = &MockProcessWatcher{}

// MockProcessWatcher is a mock implementation of psnotify.ProcessWatcher.
//
//	func TestSomethingThatUsesProcessWatcher(t *testing.T) {
//
//		// make and configure a mocked psnotify.ProcessWatcher
//		mockedProcessWatcher := &MockProcessWatcher{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			GetErrorChannelFunc: func() <-chan error {
//				panic("mock out the GetErrorChannel method")
//			},
//			GetExecChannelFunc: func() <-chan *psnotify.ProcEventExec {
//				panic("mock out the GetExecChannel method")
//			},
//			GetExitChannelFunc: func() <-chan *psnotify.ProcEventExit {
//				panic("mock out the GetExitChannel method")
//			},
//			GetForkChannelFunc: func() <-chan *psnotify.ProcEventFork {
//				panic("mock out the GetForkChannel method")
//			},
//			RemoveWatchFunc: func(pid int) error {
//				panic("mock out the RemoveWatch method")
//			},
//			WatchFunc: func(pid int, flags uint32) error {
//				panic("mock out the Watch method")
//			},
//		}
//
//		// use mockedProcessWatcher in code that requires psnotify.ProcessWatcher
//		// and then make assertions.
//
//	}
type MockProcessWatcher struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// GetErrorChannelFunc mocks the GetErrorChannel method.
	GetErrorChannelFunc func() <-chan error

	// GetExecChannelFunc mocks the GetExecChannel method.
	GetExecChannelFunc func() <-chan *psnotify.ProcEventExec

	// GetExitChannelFunc mocks the GetExitChannel method.
	GetExitChannelFunc func() <-chan *psnotify.ProcEventExit

	// GetForkChannelFunc mocks the GetForkChannel method.
	GetForkChannelFunc func() <-chan *psnotify.ProcEventFork

	// RemoveWatchFunc mocks the RemoveWatch method.
	RemoveWatchFunc func(pid int) error

	// WatchFunc mocks the Watch method.
	WatchFunc func(pid int, flags uint32) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// GetErrorChannel holds details about calls to the GetErrorChannel method.
		GetErrorChannel []struct {
		}
		// GetExecChannel holds details about calls to the GetExecChannel method.
		GetExecChannel []struct {
		}
		// GetExitChannel holds details about calls to the GetExitChannel method.
		GetExitChannel []struct {
		}
		// GetForkChannel holds details about calls to the GetForkChannel method.
		GetForkChannel []struct {
		}
		// RemoveWatch holds details about calls to the RemoveWatch method.
		RemoveWatch []struct {
			// Pid is the pid argument value.
			Pid int
		}
		// Watch holds details about calls to the Watch method.
		Watch []struct {
			// Pid is the pid argument value.
			Pid int
			// Flags is the flags argument value.
			Flags uint32
		}
	}
	lockClose           sync.RWMutex
	lockGetErrorChannel sync.RWMutex
	lockGetExecChannel  sync.RWMutex
	lockGetExitChannel  sync.RWMutex
	lockGetForkChannel  sync.RWMutex
	lockRemoveWatch     sync.RWMutex
	lockWatch           sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MockProcessWatcher) Close() error {
	if mock.CloseFunc == nil {
		panic("MockProcessWatcher.CloseFunc: method is nil but ProcessWatcher.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedProcessWatcher.CloseCalls())
func (mock *MockProcessWatcher) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetErrorChannel calls GetErrorChannelFunc.
func (mock *MockProcessWatcher) GetErrorChannel() <-chan error {
	if mock.GetErrorChannelFunc == nil {
		panic("MockProcessWatcher.GetErrorChannelFunc: method is nil but ProcessWatcher.GetErrorChannel was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetErrorChannel.Lock()
	mock.calls.GetErrorChannel = append(mock.calls.GetErrorChannel, callInfo)
	mock.lockGetErrorChannel.Unlock()
	return mock.GetErrorChannelFunc()
}

// GetErrorChannelCalls gets all the calls that were made to GetErrorChannel.
// Check the length with:
//
//	len(mockedProcessWatcher.GetErrorChannelCalls())
func (mock *MockProcessWatcher) GetErrorChannelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetErrorChannel.RLock()
	calls = mock.calls.GetErrorChannel
	mock.lockGetErrorChannel.RUnlock()
	return calls
}

// GetExecChannel calls GetExecChannelFunc.
func (mock *MockProcessWatcher) GetExecChannel() <-chan *psnotify.ProcEventExec {
	if mock.GetExecChannelFunc == nil {
		panic("MockProcessWatcher.GetExecChannelFunc: method is nil but ProcessWatcher.GetExecChannel was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetExecChannel.Lock()
	mock.calls.GetExecChannel = append(mock.calls.GetExecChannel, callInfo)
	mock.lockGetExecChannel.Unlock()
	return mock.GetExecChannelFunc()
}

// GetExecChannelCalls gets all the calls that were made to GetExecChannel.
// Check the length with:
//
//	len(mockedProcessWatcher.GetExecChannelCalls())
func (mock *MockProcessWatcher) GetExecChannelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetExecChannel.RLock()
	calls = mock.calls.GetExecChannel
	mock.lockGetExecChannel.RUnlock()
	return calls
}

// GetExitChannel calls GetExitChannelFunc.
func (mock *MockProcessWatcher) GetExitChannel() <-chan *psnotify.ProcEventExit {
	if mock.GetExitChannelFunc == nil {
		panic("MockProcessWatcher.GetExitChannelFunc: method is nil but ProcessWatcher.GetExitChannel was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetExitChannel.Lock()
	mock.calls.GetExitChannel = append(mock.calls.GetExitChannel, callInfo)
	mock.lockGetExitChannel.Unlock()
	return mock.GetExitChannelFunc()
}

// GetExitChannelCalls gets all the calls that were made to GetExitChannel.
// Check the length with:
//
//	len(mockedProcessWatcher.GetExitChannelCalls())
func (mock *MockProcessWatcher) GetExitChannelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetExitChannel.RLock()
	calls = mock.calls.GetExitChannel
	mock.lockGetExitChannel.RUnlock()
	return calls
}

// GetForkChannel calls GetForkChannelFunc.
func (mock *MockProcessWatcher) GetForkChannel() <-chan *psnotify.ProcEventFork {
	if mock.GetForkChannelFunc == nil {
		panic("MockProcessWatcher.GetForkChannelFunc: method is nil but ProcessWatcher.GetForkChannel was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetForkChannel.Lock()
	mock.calls.GetForkChannel = append(mock.calls.GetForkChannel, callInfo)
	mock.lockGetForkChannel.Unlock()
	return mock.GetForkChannelFunc()
}

// GetForkChannelCalls gets all the calls that were made to GetForkChannel.
// Check the length with:
//
//	len(mockedProcessWatcher.GetForkChannelCalls())
func (mock *MockProcessWatcher) GetForkChannelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetForkChannel.RLock()
	calls = mock.calls.GetForkChannel
	mock.lockGetForkChannel.RUnlock()
	return calls
}

// RemoveWatch calls RemoveWatchFunc.
func (mock *MockProcessWatcher) RemoveWatch(pid int) error {
	if mock.RemoveWatchFunc == nil {
		panic("MockProcessWatcher.RemoveWatchFunc: method is nil but ProcessWatcher.RemoveWatch was just called")
	}
	callInfo := struct {
		Pid int
	}{
		Pid: pid,
	}
	mock.lockRemoveWatch.Lock()
	mock.calls.RemoveWatch = append(mock.calls.RemoveWatch, callInfo)
	mock.lockRemoveWatch.Unlock()
	return mock.RemoveWatchFunc(pid)
}

// RemoveWatchCalls gets all the calls that were made to RemoveWatch.
// Check the length with:
//
//	len(mockedProcessWatcher.RemoveWatchCalls())
func (mock *MockProcessWatcher) RemoveWatchCalls() []struct {
	Pid int
} {
	var calls []struct {
		Pid int
	}
	mock.lockRemoveWatch.RLock()
	calls = mock.calls.RemoveWatch
	mock.lockRemoveWatch.RUnlock()
	return calls
}

// Watch calls WatchFunc.
func (mock *MockProcessWatcher) Watch(pid int, flags uint32) error {
	if mock.WatchFunc == nil {
		panic("MockProcessWatcher.WatchFunc: method is nil but ProcessWatcher.Watch was just called")
	}
	callInfo := struct {
		Pid   int
		Flags uint32
	}{
		Pid:   pid,
		Flags: flags,
	}
	mock.lockWatch.Lock()
	mock.calls.Watch = append(mock.calls.Watch, callInfo)
	mock.lockWatch.Unlock()
	return mock.WatchFunc(pid, flags)
}

// WatchCalls gets all the calls that were made to Watch.
// Check the length with:
//
//	len(mockedProcessWatcher.WatchCalls())
func (mock *MockProcessWatcher) WatchCalls() []struct {
	Pid   int
	Flags uint32
} {
	var calls []struct {
		Pid   int
		Flags uint32
	}
	mock.lockWatch.RLock()
	calls = mock.calls.Watch
	mock.lockWatch.RUnlock()
	return calls
}
