// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockpsnotify

import (
	"sync"

	"github.com/walteh/runm/pkg/psnotify"
)

// Ensure that MockProcessDetector does implement psnotify.ProcessDetector.
// If this is not the case, regenerate this file with mockery.
var _ psnotify.ProcessDetector = &MockProcessDetector{}

// MockProcessDetector is a mock implementation of psnotify.ProcessDetector.
//
//	func TestSomethingThatUsesProcessDetector(t *testing.T) {
//
//		// make and configure a mocked psnotify.ProcessDetector
//		mockedProcessDetector := &MockProcessDetector{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			GetDoneChannelFunc: func() <-chan *psnotify.DetectedEventDone {
//				panic("mock out the GetDoneChannel method")
//			},
//			GetErrorChannelFunc: func() <-chan error {
//				panic("mock out the GetErrorChannel method")
//			},
//			GetForkExecChannelFunc: func() <-chan *psnotify.DetectedEventForkExec {
//				panic("mock out the GetForkExecChannel method")
//			},
//			RemoveWatchFunc: func(pid int) error {
//				panic("mock out the RemoveWatch method")
//			},
//			WatchFunc: func(pid int, flags uint32) error {
//				panic("mock out the Watch method")
//			},
//		}
//
//		// use mockedProcessDetector in code that requires psnotify.ProcessDetector
//		// and then make assertions.
//
//	}
type MockProcessDetector struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// GetDoneChannelFunc mocks the GetDoneChannel method.
	GetDoneChannelFunc func() <-chan *psnotify.DetectedEventDone

	// GetErrorChannelFunc mocks the GetErrorChannel method.
	GetErrorChannelFunc func() <-chan error

	// GetForkExecChannelFunc mocks the GetForkExecChannel method.
	GetForkExecChannelFunc func() <-chan *psnotify.DetectedEventForkExec

	// RemoveWatchFunc mocks the RemoveWatch method.
	RemoveWatchFunc func(pid int) error

	// WatchFunc mocks the Watch method.
	WatchFunc func(pid int, flags uint32) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// GetDoneChannel holds details about calls to the GetDoneChannel method.
		GetDoneChannel []struct {
		}
		// GetErrorChannel holds details about calls to the GetErrorChannel method.
		GetErrorChannel []struct {
		}
		// GetForkExecChannel holds details about calls to the GetForkExecChannel method.
		GetForkExecChannel []struct {
		}
		// RemoveWatch holds details about calls to the RemoveWatch method.
		RemoveWatch []struct {
			// Pid is the pid argument value.
			Pid int
		}
		// Watch holds details about calls to the Watch method.
		Watch []struct {
			// Pid is the pid argument value.
			Pid int
			// Flags is the flags argument value.
			Flags uint32
		}
	}
	lockClose              sync.RWMutex
	lockGetDoneChannel     sync.RWMutex
	lockGetErrorChannel    sync.RWMutex
	lockGetForkExecChannel sync.RWMutex
	lockRemoveWatch        sync.RWMutex
	lockWatch              sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MockProcessDetector) Close() error {
	if mock.CloseFunc == nil {
		panic("MockProcessDetector.CloseFunc: method is nil but ProcessDetector.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedProcessDetector.CloseCalls())
func (mock *MockProcessDetector) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetDoneChannel calls GetDoneChannelFunc.
func (mock *MockProcessDetector) GetDoneChannel() <-chan *psnotify.DetectedEventDone {
	if mock.GetDoneChannelFunc == nil {
		panic("MockProcessDetector.GetDoneChannelFunc: method is nil but ProcessDetector.GetDoneChannel was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetDoneChannel.Lock()
	mock.calls.GetDoneChannel = append(mock.calls.GetDoneChannel, callInfo)
	mock.lockGetDoneChannel.Unlock()
	return mock.GetDoneChannelFunc()
}

// GetDoneChannelCalls gets all the calls that were made to GetDoneChannel.
// Check the length with:
//
//	len(mockedProcessDetector.GetDoneChannelCalls())
func (mock *MockProcessDetector) GetDoneChannelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetDoneChannel.RLock()
	calls = mock.calls.GetDoneChannel
	mock.lockGetDoneChannel.RUnlock()
	return calls
}

// GetErrorChannel calls GetErrorChannelFunc.
func (mock *MockProcessDetector) GetErrorChannel() <-chan error {
	if mock.GetErrorChannelFunc == nil {
		panic("MockProcessDetector.GetErrorChannelFunc: method is nil but ProcessDetector.GetErrorChannel was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetErrorChannel.Lock()
	mock.calls.GetErrorChannel = append(mock.calls.GetErrorChannel, callInfo)
	mock.lockGetErrorChannel.Unlock()
	return mock.GetErrorChannelFunc()
}

// GetErrorChannelCalls gets all the calls that were made to GetErrorChannel.
// Check the length with:
//
//	len(mockedProcessDetector.GetErrorChannelCalls())
func (mock *MockProcessDetector) GetErrorChannelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetErrorChannel.RLock()
	calls = mock.calls.GetErrorChannel
	mock.lockGetErrorChannel.RUnlock()
	return calls
}

// GetForkExecChannel calls GetForkExecChannelFunc.
func (mock *MockProcessDetector) GetForkExecChannel() <-chan *psnotify.DetectedEventForkExec {
	if mock.GetForkExecChannelFunc == nil {
		panic("MockProcessDetector.GetForkExecChannelFunc: method is nil but ProcessDetector.GetForkExecChannel was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetForkExecChannel.Lock()
	mock.calls.GetForkExecChannel = append(mock.calls.GetForkExecChannel, callInfo)
	mock.lockGetForkExecChannel.Unlock()
	return mock.GetForkExecChannelFunc()
}

// GetForkExecChannelCalls gets all the calls that were made to GetForkExecChannel.
// Check the length with:
//
//	len(mockedProcessDetector.GetForkExecChannelCalls())
func (mock *MockProcessDetector) GetForkExecChannelCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetForkExecChannel.RLock()
	calls = mock.calls.GetForkExecChannel
	mock.lockGetForkExecChannel.RUnlock()
	return calls
}

// RemoveWatch calls RemoveWatchFunc.
func (mock *MockProcessDetector) RemoveWatch(pid int) error {
	if mock.RemoveWatchFunc == nil {
		panic("MockProcessDetector.RemoveWatchFunc: method is nil but ProcessDetector.RemoveWatch was just called")
	}
	callInfo := struct {
		Pid int
	}{
		Pid: pid,
	}
	mock.lockRemoveWatch.Lock()
	mock.calls.RemoveWatch = append(mock.calls.RemoveWatch, callInfo)
	mock.lockRemoveWatch.Unlock()
	return mock.RemoveWatchFunc(pid)
}

// RemoveWatchCalls gets all the calls that were made to RemoveWatch.
// Check the length with:
//
//	len(mockedProcessDetector.RemoveWatchCalls())
func (mock *MockProcessDetector) RemoveWatchCalls() []struct {
	Pid int
} {
	var calls []struct {
		Pid int
	}
	mock.lockRemoveWatch.RLock()
	calls = mock.calls.RemoveWatch
	mock.lockRemoveWatch.RUnlock()
	return calls
}

// Watch calls WatchFunc.
func (mock *MockProcessDetector) Watch(pid int, flags uint32) error {
	if mock.WatchFunc == nil {
		panic("MockProcessDetector.WatchFunc: method is nil but ProcessDetector.Watch was just called")
	}
	callInfo := struct {
		Pid   int
		Flags uint32
	}{
		Pid:   pid,
		Flags: flags,
	}
	mock.lockWatch.Lock()
	mock.calls.Watch = append(mock.calls.Watch, callInfo)
	mock.lockWatch.Unlock()
	return mock.WatchFunc(pid, flags)
}

// WatchCalls gets all the calls that were made to Watch.
// Check the length with:
//
//	len(mockedProcessDetector.WatchCalls())
func (mock *MockProcessDetector) WatchCalls() []struct {
	Pid   int
	Flags uint32
} {
	var calls []struct {
		Pid   int
		Flags uint32
	}
	mock.lockWatch.RLock()
	calls = mock.calls.Watch
	mock.lockWatch.RUnlock()
	return calls
}
