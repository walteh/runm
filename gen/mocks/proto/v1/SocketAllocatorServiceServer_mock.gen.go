// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockrunmv1

import (
	"context"
	"sync"

	"github.com/walteh/runm/proto/v1"
)

// Ensure that MockSocketAllocatorServiceServer does implement runmv1.SocketAllocatorServiceServer.
// If this is not the case, regenerate this file with mockery.
var _ runmv1.SocketAllocatorServiceServer = &MockSocketAllocatorServiceServer{}

// MockSocketAllocatorServiceServer is a mock implementation of runmv1.SocketAllocatorServiceServer.
//
//	func TestSomethingThatUsesSocketAllocatorServiceServer(t *testing.T) {
//
//		// make and configure a mocked runmv1.SocketAllocatorServiceServer
//		mockedSocketAllocatorServiceServer := &MockSocketAllocatorServiceServer{
//			AllocateConsoleFunc: func(context1 context.Context, allocateConsoleRequest *runmv1.AllocateConsoleRequest) (*runmv1.AllocateConsoleResponse, error) {
//				panic("mock out the AllocateConsole method")
//			},
//			AllocateIOFunc: func(context1 context.Context, allocateIORequest *runmv1.AllocateIORequest) (*runmv1.AllocateIOResponse, error) {
//				panic("mock out the AllocateIO method")
//			},
//			BindConsoleToSocketFunc: func(context1 context.Context, bindConsoleToSocketRequest *runmv1.BindConsoleToSocketRequest) (*runmv1.BindConsoleToSocketResponse, error) {
//				panic("mock out the BindConsoleToSocket method")
//			},
//			BindIOToSocketsFunc: func(context1 context.Context, bindIOToSocketsRequest *runmv1.BindIOToSocketsRequest) (*runmv1.BindIOToSocketsResponse, error) {
//				panic("mock out the BindIOToSockets method")
//			},
//			CloseConsoleFunc: func(context1 context.Context, closeConsoleRequest *runmv1.CloseConsoleRequest) (*runmv1.CloseConsoleResponse, error) {
//				panic("mock out the CloseConsole method")
//			},
//			CloseIOFunc: func(context1 context.Context, closeIORequest *runmv1.CloseIORequest) (*runmv1.CloseIOResponse, error) {
//				panic("mock out the CloseIO method")
//			},
//			CloseSocketFunc: func(context1 context.Context, closeSocketRequest *runmv1.CloseSocketRequest) (*runmv1.CloseSocketResponse, error) {
//				panic("mock out the CloseSocket method")
//			},
//			CloseSocketsFunc: func(context1 context.Context, closeSocketsRequest *runmv1.CloseSocketsRequest) (*runmv1.CloseSocketsResponse, error) {
//				panic("mock out the CloseSockets method")
//			},
//			DialOpenListenerFunc: func(context1 context.Context, dialOpenListenerRequest *runmv1.DialOpenListenerRequest) (*runmv1.DialOpenListenerResponse, error) {
//				panic("mock out the DialOpenListener method")
//			},
//		}
//
//		// use mockedSocketAllocatorServiceServer in code that requires runmv1.SocketAllocatorServiceServer
//		// and then make assertions.
//
//	}
type MockSocketAllocatorServiceServer struct {
	// AllocateConsoleFunc mocks the AllocateConsole method.
	AllocateConsoleFunc func(context1 context.Context, allocateConsoleRequest *runmv1.AllocateConsoleRequest) (*runmv1.AllocateConsoleResponse, error)

	// AllocateIOFunc mocks the AllocateIO method.
	AllocateIOFunc func(context1 context.Context, allocateIORequest *runmv1.AllocateIORequest) (*runmv1.AllocateIOResponse, error)

	// BindConsoleToSocketFunc mocks the BindConsoleToSocket method.
	BindConsoleToSocketFunc func(context1 context.Context, bindConsoleToSocketRequest *runmv1.BindConsoleToSocketRequest) (*runmv1.BindConsoleToSocketResponse, error)

	// BindIOToSocketsFunc mocks the BindIOToSockets method.
	BindIOToSocketsFunc func(context1 context.Context, bindIOToSocketsRequest *runmv1.BindIOToSocketsRequest) (*runmv1.BindIOToSocketsResponse, error)

	// CloseConsoleFunc mocks the CloseConsole method.
	CloseConsoleFunc func(context1 context.Context, closeConsoleRequest *runmv1.CloseConsoleRequest) (*runmv1.CloseConsoleResponse, error)

	// CloseIOFunc mocks the CloseIO method.
	CloseIOFunc func(context1 context.Context, closeIORequest *runmv1.CloseIORequest) (*runmv1.CloseIOResponse, error)

	// CloseSocketFunc mocks the CloseSocket method.
	CloseSocketFunc func(context1 context.Context, closeSocketRequest *runmv1.CloseSocketRequest) (*runmv1.CloseSocketResponse, error)

	// CloseSocketsFunc mocks the CloseSockets method.
	CloseSocketsFunc func(context1 context.Context, closeSocketsRequest *runmv1.CloseSocketsRequest) (*runmv1.CloseSocketsResponse, error)

	// DialOpenListenerFunc mocks the DialOpenListener method.
	DialOpenListenerFunc func(context1 context.Context, dialOpenListenerRequest *runmv1.DialOpenListenerRequest) (*runmv1.DialOpenListenerResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// AllocateConsole holds details about calls to the AllocateConsole method.
		AllocateConsole []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// AllocateConsoleRequest is the allocateConsoleRequest argument value.
			AllocateConsoleRequest *runmv1.AllocateConsoleRequest
		}
		// AllocateIO holds details about calls to the AllocateIO method.
		AllocateIO []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// AllocateIORequest is the allocateIORequest argument value.
			AllocateIORequest *runmv1.AllocateIORequest
		}
		// BindConsoleToSocket holds details about calls to the BindConsoleToSocket method.
		BindConsoleToSocket []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// BindConsoleToSocketRequest is the bindConsoleToSocketRequest argument value.
			BindConsoleToSocketRequest *runmv1.BindConsoleToSocketRequest
		}
		// BindIOToSockets holds details about calls to the BindIOToSockets method.
		BindIOToSockets []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// BindIOToSocketsRequest is the bindIOToSocketsRequest argument value.
			BindIOToSocketsRequest *runmv1.BindIOToSocketsRequest
		}
		// CloseConsole holds details about calls to the CloseConsole method.
		CloseConsole []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// CloseConsoleRequest is the closeConsoleRequest argument value.
			CloseConsoleRequest *runmv1.CloseConsoleRequest
		}
		// CloseIO holds details about calls to the CloseIO method.
		CloseIO []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// CloseIORequest is the closeIORequest argument value.
			CloseIORequest *runmv1.CloseIORequest
		}
		// CloseSocket holds details about calls to the CloseSocket method.
		CloseSocket []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// CloseSocketRequest is the closeSocketRequest argument value.
			CloseSocketRequest *runmv1.CloseSocketRequest
		}
		// CloseSockets holds details about calls to the CloseSockets method.
		CloseSockets []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// CloseSocketsRequest is the closeSocketsRequest argument value.
			CloseSocketsRequest *runmv1.CloseSocketsRequest
		}
		// DialOpenListener holds details about calls to the DialOpenListener method.
		DialOpenListener []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// DialOpenListenerRequest is the dialOpenListenerRequest argument value.
			DialOpenListenerRequest *runmv1.DialOpenListenerRequest
		}
	}
	lockAllocateConsole     sync.RWMutex
	lockAllocateIO          sync.RWMutex
	lockBindConsoleToSocket sync.RWMutex
	lockBindIOToSockets     sync.RWMutex
	lockCloseConsole        sync.RWMutex
	lockCloseIO             sync.RWMutex
	lockCloseSocket         sync.RWMutex
	lockCloseSockets        sync.RWMutex
	lockDialOpenListener    sync.RWMutex
}

// AllocateConsole calls AllocateConsoleFunc.
func (mock *MockSocketAllocatorServiceServer) AllocateConsole(context1 context.Context, allocateConsoleRequest *runmv1.AllocateConsoleRequest) (*runmv1.AllocateConsoleResponse, error) {
	if mock.AllocateConsoleFunc == nil {
		panic("MockSocketAllocatorServiceServer.AllocateConsoleFunc: method is nil but SocketAllocatorServiceServer.AllocateConsole was just called")
	}
	callInfo := struct {
		Context1               context.Context
		AllocateConsoleRequest *runmv1.AllocateConsoleRequest
	}{
		Context1:               context1,
		AllocateConsoleRequest: allocateConsoleRequest,
	}
	mock.lockAllocateConsole.Lock()
	mock.calls.AllocateConsole = append(mock.calls.AllocateConsole, callInfo)
	mock.lockAllocateConsole.Unlock()
	return mock.AllocateConsoleFunc(context1, allocateConsoleRequest)
}

// AllocateConsoleCalls gets all the calls that were made to AllocateConsole.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.AllocateConsoleCalls())
func (mock *MockSocketAllocatorServiceServer) AllocateConsoleCalls() []struct {
	Context1               context.Context
	AllocateConsoleRequest *runmv1.AllocateConsoleRequest
} {
	var calls []struct {
		Context1               context.Context
		AllocateConsoleRequest *runmv1.AllocateConsoleRequest
	}
	mock.lockAllocateConsole.RLock()
	calls = mock.calls.AllocateConsole
	mock.lockAllocateConsole.RUnlock()
	return calls
}

// AllocateIO calls AllocateIOFunc.
func (mock *MockSocketAllocatorServiceServer) AllocateIO(context1 context.Context, allocateIORequest *runmv1.AllocateIORequest) (*runmv1.AllocateIOResponse, error) {
	if mock.AllocateIOFunc == nil {
		panic("MockSocketAllocatorServiceServer.AllocateIOFunc: method is nil but SocketAllocatorServiceServer.AllocateIO was just called")
	}
	callInfo := struct {
		Context1          context.Context
		AllocateIORequest *runmv1.AllocateIORequest
	}{
		Context1:          context1,
		AllocateIORequest: allocateIORequest,
	}
	mock.lockAllocateIO.Lock()
	mock.calls.AllocateIO = append(mock.calls.AllocateIO, callInfo)
	mock.lockAllocateIO.Unlock()
	return mock.AllocateIOFunc(context1, allocateIORequest)
}

// AllocateIOCalls gets all the calls that were made to AllocateIO.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.AllocateIOCalls())
func (mock *MockSocketAllocatorServiceServer) AllocateIOCalls() []struct {
	Context1          context.Context
	AllocateIORequest *runmv1.AllocateIORequest
} {
	var calls []struct {
		Context1          context.Context
		AllocateIORequest *runmv1.AllocateIORequest
	}
	mock.lockAllocateIO.RLock()
	calls = mock.calls.AllocateIO
	mock.lockAllocateIO.RUnlock()
	return calls
}

// BindConsoleToSocket calls BindConsoleToSocketFunc.
func (mock *MockSocketAllocatorServiceServer) BindConsoleToSocket(context1 context.Context, bindConsoleToSocketRequest *runmv1.BindConsoleToSocketRequest) (*runmv1.BindConsoleToSocketResponse, error) {
	if mock.BindConsoleToSocketFunc == nil {
		panic("MockSocketAllocatorServiceServer.BindConsoleToSocketFunc: method is nil but SocketAllocatorServiceServer.BindConsoleToSocket was just called")
	}
	callInfo := struct {
		Context1                   context.Context
		BindConsoleToSocketRequest *runmv1.BindConsoleToSocketRequest
	}{
		Context1:                   context1,
		BindConsoleToSocketRequest: bindConsoleToSocketRequest,
	}
	mock.lockBindConsoleToSocket.Lock()
	mock.calls.BindConsoleToSocket = append(mock.calls.BindConsoleToSocket, callInfo)
	mock.lockBindConsoleToSocket.Unlock()
	return mock.BindConsoleToSocketFunc(context1, bindConsoleToSocketRequest)
}

// BindConsoleToSocketCalls gets all the calls that were made to BindConsoleToSocket.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.BindConsoleToSocketCalls())
func (mock *MockSocketAllocatorServiceServer) BindConsoleToSocketCalls() []struct {
	Context1                   context.Context
	BindConsoleToSocketRequest *runmv1.BindConsoleToSocketRequest
} {
	var calls []struct {
		Context1                   context.Context
		BindConsoleToSocketRequest *runmv1.BindConsoleToSocketRequest
	}
	mock.lockBindConsoleToSocket.RLock()
	calls = mock.calls.BindConsoleToSocket
	mock.lockBindConsoleToSocket.RUnlock()
	return calls
}

// BindIOToSockets calls BindIOToSocketsFunc.
func (mock *MockSocketAllocatorServiceServer) BindIOToSockets(context1 context.Context, bindIOToSocketsRequest *runmv1.BindIOToSocketsRequest) (*runmv1.BindIOToSocketsResponse, error) {
	if mock.BindIOToSocketsFunc == nil {
		panic("MockSocketAllocatorServiceServer.BindIOToSocketsFunc: method is nil but SocketAllocatorServiceServer.BindIOToSockets was just called")
	}
	callInfo := struct {
		Context1               context.Context
		BindIOToSocketsRequest *runmv1.BindIOToSocketsRequest
	}{
		Context1:               context1,
		BindIOToSocketsRequest: bindIOToSocketsRequest,
	}
	mock.lockBindIOToSockets.Lock()
	mock.calls.BindIOToSockets = append(mock.calls.BindIOToSockets, callInfo)
	mock.lockBindIOToSockets.Unlock()
	return mock.BindIOToSocketsFunc(context1, bindIOToSocketsRequest)
}

// BindIOToSocketsCalls gets all the calls that were made to BindIOToSockets.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.BindIOToSocketsCalls())
func (mock *MockSocketAllocatorServiceServer) BindIOToSocketsCalls() []struct {
	Context1               context.Context
	BindIOToSocketsRequest *runmv1.BindIOToSocketsRequest
} {
	var calls []struct {
		Context1               context.Context
		BindIOToSocketsRequest *runmv1.BindIOToSocketsRequest
	}
	mock.lockBindIOToSockets.RLock()
	calls = mock.calls.BindIOToSockets
	mock.lockBindIOToSockets.RUnlock()
	return calls
}

// CloseConsole calls CloseConsoleFunc.
func (mock *MockSocketAllocatorServiceServer) CloseConsole(context1 context.Context, closeConsoleRequest *runmv1.CloseConsoleRequest) (*runmv1.CloseConsoleResponse, error) {
	if mock.CloseConsoleFunc == nil {
		panic("MockSocketAllocatorServiceServer.CloseConsoleFunc: method is nil but SocketAllocatorServiceServer.CloseConsole was just called")
	}
	callInfo := struct {
		Context1            context.Context
		CloseConsoleRequest *runmv1.CloseConsoleRequest
	}{
		Context1:            context1,
		CloseConsoleRequest: closeConsoleRequest,
	}
	mock.lockCloseConsole.Lock()
	mock.calls.CloseConsole = append(mock.calls.CloseConsole, callInfo)
	mock.lockCloseConsole.Unlock()
	return mock.CloseConsoleFunc(context1, closeConsoleRequest)
}

// CloseConsoleCalls gets all the calls that were made to CloseConsole.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.CloseConsoleCalls())
func (mock *MockSocketAllocatorServiceServer) CloseConsoleCalls() []struct {
	Context1            context.Context
	CloseConsoleRequest *runmv1.CloseConsoleRequest
} {
	var calls []struct {
		Context1            context.Context
		CloseConsoleRequest *runmv1.CloseConsoleRequest
	}
	mock.lockCloseConsole.RLock()
	calls = mock.calls.CloseConsole
	mock.lockCloseConsole.RUnlock()
	return calls
}

// CloseIO calls CloseIOFunc.
func (mock *MockSocketAllocatorServiceServer) CloseIO(context1 context.Context, closeIORequest *runmv1.CloseIORequest) (*runmv1.CloseIOResponse, error) {
	if mock.CloseIOFunc == nil {
		panic("MockSocketAllocatorServiceServer.CloseIOFunc: method is nil but SocketAllocatorServiceServer.CloseIO was just called")
	}
	callInfo := struct {
		Context1       context.Context
		CloseIORequest *runmv1.CloseIORequest
	}{
		Context1:       context1,
		CloseIORequest: closeIORequest,
	}
	mock.lockCloseIO.Lock()
	mock.calls.CloseIO = append(mock.calls.CloseIO, callInfo)
	mock.lockCloseIO.Unlock()
	return mock.CloseIOFunc(context1, closeIORequest)
}

// CloseIOCalls gets all the calls that were made to CloseIO.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.CloseIOCalls())
func (mock *MockSocketAllocatorServiceServer) CloseIOCalls() []struct {
	Context1       context.Context
	CloseIORequest *runmv1.CloseIORequest
} {
	var calls []struct {
		Context1       context.Context
		CloseIORequest *runmv1.CloseIORequest
	}
	mock.lockCloseIO.RLock()
	calls = mock.calls.CloseIO
	mock.lockCloseIO.RUnlock()
	return calls
}

// CloseSocket calls CloseSocketFunc.
func (mock *MockSocketAllocatorServiceServer) CloseSocket(context1 context.Context, closeSocketRequest *runmv1.CloseSocketRequest) (*runmv1.CloseSocketResponse, error) {
	if mock.CloseSocketFunc == nil {
		panic("MockSocketAllocatorServiceServer.CloseSocketFunc: method is nil but SocketAllocatorServiceServer.CloseSocket was just called")
	}
	callInfo := struct {
		Context1           context.Context
		CloseSocketRequest *runmv1.CloseSocketRequest
	}{
		Context1:           context1,
		CloseSocketRequest: closeSocketRequest,
	}
	mock.lockCloseSocket.Lock()
	mock.calls.CloseSocket = append(mock.calls.CloseSocket, callInfo)
	mock.lockCloseSocket.Unlock()
	return mock.CloseSocketFunc(context1, closeSocketRequest)
}

// CloseSocketCalls gets all the calls that were made to CloseSocket.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.CloseSocketCalls())
func (mock *MockSocketAllocatorServiceServer) CloseSocketCalls() []struct {
	Context1           context.Context
	CloseSocketRequest *runmv1.CloseSocketRequest
} {
	var calls []struct {
		Context1           context.Context
		CloseSocketRequest *runmv1.CloseSocketRequest
	}
	mock.lockCloseSocket.RLock()
	calls = mock.calls.CloseSocket
	mock.lockCloseSocket.RUnlock()
	return calls
}

// CloseSockets calls CloseSocketsFunc.
func (mock *MockSocketAllocatorServiceServer) CloseSockets(context1 context.Context, closeSocketsRequest *runmv1.CloseSocketsRequest) (*runmv1.CloseSocketsResponse, error) {
	if mock.CloseSocketsFunc == nil {
		panic("MockSocketAllocatorServiceServer.CloseSocketsFunc: method is nil but SocketAllocatorServiceServer.CloseSockets was just called")
	}
	callInfo := struct {
		Context1            context.Context
		CloseSocketsRequest *runmv1.CloseSocketsRequest
	}{
		Context1:            context1,
		CloseSocketsRequest: closeSocketsRequest,
	}
	mock.lockCloseSockets.Lock()
	mock.calls.CloseSockets = append(mock.calls.CloseSockets, callInfo)
	mock.lockCloseSockets.Unlock()
	return mock.CloseSocketsFunc(context1, closeSocketsRequest)
}

// CloseSocketsCalls gets all the calls that were made to CloseSockets.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.CloseSocketsCalls())
func (mock *MockSocketAllocatorServiceServer) CloseSocketsCalls() []struct {
	Context1            context.Context
	CloseSocketsRequest *runmv1.CloseSocketsRequest
} {
	var calls []struct {
		Context1            context.Context
		CloseSocketsRequest *runmv1.CloseSocketsRequest
	}
	mock.lockCloseSockets.RLock()
	calls = mock.calls.CloseSockets
	mock.lockCloseSockets.RUnlock()
	return calls
}

// DialOpenListener calls DialOpenListenerFunc.
func (mock *MockSocketAllocatorServiceServer) DialOpenListener(context1 context.Context, dialOpenListenerRequest *runmv1.DialOpenListenerRequest) (*runmv1.DialOpenListenerResponse, error) {
	if mock.DialOpenListenerFunc == nil {
		panic("MockSocketAllocatorServiceServer.DialOpenListenerFunc: method is nil but SocketAllocatorServiceServer.DialOpenListener was just called")
	}
	callInfo := struct {
		Context1                context.Context
		DialOpenListenerRequest *runmv1.DialOpenListenerRequest
	}{
		Context1:                context1,
		DialOpenListenerRequest: dialOpenListenerRequest,
	}
	mock.lockDialOpenListener.Lock()
	mock.calls.DialOpenListener = append(mock.calls.DialOpenListener, callInfo)
	mock.lockDialOpenListener.Unlock()
	return mock.DialOpenListenerFunc(context1, dialOpenListenerRequest)
}

// DialOpenListenerCalls gets all the calls that were made to DialOpenListener.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceServer.DialOpenListenerCalls())
func (mock *MockSocketAllocatorServiceServer) DialOpenListenerCalls() []struct {
	Context1                context.Context
	DialOpenListenerRequest *runmv1.DialOpenListenerRequest
} {
	var calls []struct {
		Context1                context.Context
		DialOpenListenerRequest *runmv1.DialOpenListenerRequest
	}
	mock.lockDialOpenListener.RLock()
	calls = mock.calls.DialOpenListener
	mock.lockDialOpenListener.RUnlock()
	return calls
}
