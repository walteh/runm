// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockrunmv1

import (
	"context"
	"sync"

	"github.com/walteh/runm/proto/v1"
	"google.golang.org/grpc"
)

// Ensure that MockRuncExtrasServiceClient does implement runmv1.RuncExtrasServiceClient.
// If this is not the case, regenerate this file with mockery.
var _ runmv1.RuncExtrasServiceClient = &MockRuncExtrasServiceClient{}

// MockRuncExtrasServiceClient is a mock implementation of runmv1.RuncExtrasServiceClient.
//
//	func TestSomethingThatUsesRuncExtrasServiceClient(t *testing.T) {
//
//		// make and configure a mocked runmv1.RuncExtrasServiceClient
//		mockedRuncExtrasServiceClient := &MockRuncExtrasServiceClient{
//			EventsFunc: func(ctx context.Context, in *runmv1.RuncEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runmv1.RuncEvent], error) {
//				panic("mock out the Events method")
//			},
//			ListFunc: func(ctx context.Context, in *runmv1.RuncListRequest, opts ...grpc.CallOption) (*runmv1.RuncListResponse, error) {
//				panic("mock out the List method")
//			},
//			RuncRunFunc: func(ctx context.Context, in *runmv1.RuncRunRequest, opts ...grpc.CallOption) (*runmv1.RuncRunResponse, error) {
//				panic("mock out the RuncRun method")
//			},
//			StateFunc: func(ctx context.Context, in *runmv1.RuncStateRequest, opts ...grpc.CallOption) (*runmv1.RuncStateResponse, error) {
//				panic("mock out the State method")
//			},
//			StatsFunc: func(ctx context.Context, in *runmv1.RuncStatsRequest, opts ...grpc.CallOption) (*runmv1.RuncStatsResponse, error) {
//				panic("mock out the Stats method")
//			},
//			TopFunc: func(ctx context.Context, in *runmv1.RuncTopRequest, opts ...grpc.CallOption) (*runmv1.RuncTopResponse, error) {
//				panic("mock out the Top method")
//			},
//			VersionFunc: func(ctx context.Context, in *runmv1.RuncVersionRequest, opts ...grpc.CallOption) (*runmv1.RuncVersionResponse, error) {
//				panic("mock out the Version method")
//			},
//		}
//
//		// use mockedRuncExtrasServiceClient in code that requires runmv1.RuncExtrasServiceClient
//		// and then make assertions.
//
//	}
type MockRuncExtrasServiceClient struct {
	// EventsFunc mocks the Events method.
	EventsFunc func(ctx context.Context, in *runmv1.RuncEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runmv1.RuncEvent], error)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, in *runmv1.RuncListRequest, opts ...grpc.CallOption) (*runmv1.RuncListResponse, error)

	// RuncRunFunc mocks the RuncRun method.
	RuncRunFunc func(ctx context.Context, in *runmv1.RuncRunRequest, opts ...grpc.CallOption) (*runmv1.RuncRunResponse, error)

	// StateFunc mocks the State method.
	StateFunc func(ctx context.Context, in *runmv1.RuncStateRequest, opts ...grpc.CallOption) (*runmv1.RuncStateResponse, error)

	// StatsFunc mocks the Stats method.
	StatsFunc func(ctx context.Context, in *runmv1.RuncStatsRequest, opts ...grpc.CallOption) (*runmv1.RuncStatsResponse, error)

	// TopFunc mocks the Top method.
	TopFunc func(ctx context.Context, in *runmv1.RuncTopRequest, opts ...grpc.CallOption) (*runmv1.RuncTopResponse, error)

	// VersionFunc mocks the Version method.
	VersionFunc func(ctx context.Context, in *runmv1.RuncVersionRequest, opts ...grpc.CallOption) (*runmv1.RuncVersionResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Events holds details about calls to the Events method.
		Events []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncEventsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncListRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// RuncRun holds details about calls to the RuncRun method.
		RuncRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncRunRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// State holds details about calls to the State method.
		State []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncStateRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncStatsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Top holds details about calls to the Top method.
		Top []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncTopRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Version holds details about calls to the Version method.
		Version []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncVersionRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockEvents  sync.RWMutex
	lockList    sync.RWMutex
	lockRuncRun sync.RWMutex
	lockState   sync.RWMutex
	lockStats   sync.RWMutex
	lockTop     sync.RWMutex
	lockVersion sync.RWMutex
}

// Events calls EventsFunc.
func (mock *MockRuncExtrasServiceClient) Events(ctx context.Context, in *runmv1.RuncEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runmv1.RuncEvent], error) {
	if mock.EventsFunc == nil {
		panic("MockRuncExtrasServiceClient.EventsFunc: method is nil but RuncExtrasServiceClient.Events was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncEventsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockEvents.Lock()
	mock.calls.Events = append(mock.calls.Events, callInfo)
	mock.lockEvents.Unlock()
	return mock.EventsFunc(ctx, in, opts...)
}

// EventsCalls gets all the calls that were made to Events.
// Check the length with:
//
//	len(mockedRuncExtrasServiceClient.EventsCalls())
func (mock *MockRuncExtrasServiceClient) EventsCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncEventsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncEventsRequest
		Opts []grpc.CallOption
	}
	mock.lockEvents.RLock()
	calls = mock.calls.Events
	mock.lockEvents.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *MockRuncExtrasServiceClient) List(ctx context.Context, in *runmv1.RuncListRequest, opts ...grpc.CallOption) (*runmv1.RuncListResponse, error) {
	if mock.ListFunc == nil {
		panic("MockRuncExtrasServiceClient.ListFunc: method is nil but RuncExtrasServiceClient.List was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncListRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, in, opts...)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedRuncExtrasServiceClient.ListCalls())
func (mock *MockRuncExtrasServiceClient) ListCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncListRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncListRequest
		Opts []grpc.CallOption
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// RuncRun calls RuncRunFunc.
func (mock *MockRuncExtrasServiceClient) RuncRun(ctx context.Context, in *runmv1.RuncRunRequest, opts ...grpc.CallOption) (*runmv1.RuncRunResponse, error) {
	if mock.RuncRunFunc == nil {
		panic("MockRuncExtrasServiceClient.RuncRunFunc: method is nil but RuncExtrasServiceClient.RuncRun was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncRunRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockRuncRun.Lock()
	mock.calls.RuncRun = append(mock.calls.RuncRun, callInfo)
	mock.lockRuncRun.Unlock()
	return mock.RuncRunFunc(ctx, in, opts...)
}

// RuncRunCalls gets all the calls that were made to RuncRun.
// Check the length with:
//
//	len(mockedRuncExtrasServiceClient.RuncRunCalls())
func (mock *MockRuncExtrasServiceClient) RuncRunCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncRunRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncRunRequest
		Opts []grpc.CallOption
	}
	mock.lockRuncRun.RLock()
	calls = mock.calls.RuncRun
	mock.lockRuncRun.RUnlock()
	return calls
}

// State calls StateFunc.
func (mock *MockRuncExtrasServiceClient) State(ctx context.Context, in *runmv1.RuncStateRequest, opts ...grpc.CallOption) (*runmv1.RuncStateResponse, error) {
	if mock.StateFunc == nil {
		panic("MockRuncExtrasServiceClient.StateFunc: method is nil but RuncExtrasServiceClient.State was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncStateRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockState.Lock()
	mock.calls.State = append(mock.calls.State, callInfo)
	mock.lockState.Unlock()
	return mock.StateFunc(ctx, in, opts...)
}

// StateCalls gets all the calls that were made to State.
// Check the length with:
//
//	len(mockedRuncExtrasServiceClient.StateCalls())
func (mock *MockRuncExtrasServiceClient) StateCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncStateRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncStateRequest
		Opts []grpc.CallOption
	}
	mock.lockState.RLock()
	calls = mock.calls.State
	mock.lockState.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *MockRuncExtrasServiceClient) Stats(ctx context.Context, in *runmv1.RuncStatsRequest, opts ...grpc.CallOption) (*runmv1.RuncStatsResponse, error) {
	if mock.StatsFunc == nil {
		panic("MockRuncExtrasServiceClient.StatsFunc: method is nil but RuncExtrasServiceClient.Stats was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncStatsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	return mock.StatsFunc(ctx, in, opts...)
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedRuncExtrasServiceClient.StatsCalls())
func (mock *MockRuncExtrasServiceClient) StatsCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncStatsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncStatsRequest
		Opts []grpc.CallOption
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// Top calls TopFunc.
func (mock *MockRuncExtrasServiceClient) Top(ctx context.Context, in *runmv1.RuncTopRequest, opts ...grpc.CallOption) (*runmv1.RuncTopResponse, error) {
	if mock.TopFunc == nil {
		panic("MockRuncExtrasServiceClient.TopFunc: method is nil but RuncExtrasServiceClient.Top was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncTopRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockTop.Lock()
	mock.calls.Top = append(mock.calls.Top, callInfo)
	mock.lockTop.Unlock()
	return mock.TopFunc(ctx, in, opts...)
}

// TopCalls gets all the calls that were made to Top.
// Check the length with:
//
//	len(mockedRuncExtrasServiceClient.TopCalls())
func (mock *MockRuncExtrasServiceClient) TopCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncTopRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncTopRequest
		Opts []grpc.CallOption
	}
	mock.lockTop.RLock()
	calls = mock.calls.Top
	mock.lockTop.RUnlock()
	return calls
}

// Version calls VersionFunc.
func (mock *MockRuncExtrasServiceClient) Version(ctx context.Context, in *runmv1.RuncVersionRequest, opts ...grpc.CallOption) (*runmv1.RuncVersionResponse, error) {
	if mock.VersionFunc == nil {
		panic("MockRuncExtrasServiceClient.VersionFunc: method is nil but RuncExtrasServiceClient.Version was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncVersionRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockVersion.Lock()
	mock.calls.Version = append(mock.calls.Version, callInfo)
	mock.lockVersion.Unlock()
	return mock.VersionFunc(ctx, in, opts...)
}

// VersionCalls gets all the calls that were made to Version.
// Check the length with:
//
//	len(mockedRuncExtrasServiceClient.VersionCalls())
func (mock *MockRuncExtrasServiceClient) VersionCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncVersionRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncVersionRequest
		Opts []grpc.CallOption
	}
	mock.lockVersion.RLock()
	calls = mock.calls.Version
	mock.lockVersion.RUnlock()
	return calls
}
