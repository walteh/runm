// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockrunmv1

import (
	"context"
	"sync"

	"github.com/walteh/runm/proto/v1"
	"google.golang.org/grpc"
)

// Ensure that MockSocketAllocatorServiceClient does implement runmv1.SocketAllocatorServiceClient.
// If this is not the case, regenerate this file with mockery.
var _ runmv1.SocketAllocatorServiceClient = &MockSocketAllocatorServiceClient{}

// MockSocketAllocatorServiceClient is a mock implementation of runmv1.SocketAllocatorServiceClient.
//
//	func TestSomethingThatUsesSocketAllocatorServiceClient(t *testing.T) {
//
//		// make and configure a mocked runmv1.SocketAllocatorServiceClient
//		mockedSocketAllocatorServiceClient := &MockSocketAllocatorServiceClient{
//			AllocateConsoleFunc: func(ctx context.Context, in *runmv1.AllocateConsoleRequest, opts ...grpc.CallOption) (*runmv1.AllocateConsoleResponse, error) {
//				panic("mock out the AllocateConsole method")
//			},
//			AllocateIOFunc: func(ctx context.Context, in *runmv1.AllocateIORequest, opts ...grpc.CallOption) (*runmv1.AllocateIOResponse, error) {
//				panic("mock out the AllocateIO method")
//			},
//			AllocateSocketStreamFunc: func(ctx context.Context, in *runmv1.AllocateSocketStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runmv1.AllocateSocketStreamResponse], error) {
//				panic("mock out the AllocateSocketStream method")
//			},
//			AllocateSocketsFunc: func(ctx context.Context, in *runmv1.AllocateSocketsRequest, opts ...grpc.CallOption) (*runmv1.AllocateSocketsResponse, error) {
//				panic("mock out the AllocateSockets method")
//			},
//			BindConsoleToSocketFunc: func(ctx context.Context, in *runmv1.BindConsoleToSocketRequest, opts ...grpc.CallOption) (*runmv1.BindConsoleToSocketResponse, error) {
//				panic("mock out the BindConsoleToSocket method")
//			},
//			BindIOToSocketsFunc: func(ctx context.Context, in *runmv1.BindIOToSocketsRequest, opts ...grpc.CallOption) (*runmv1.BindIOToSocketsResponse, error) {
//				panic("mock out the BindIOToSockets method")
//			},
//			CloseConsoleFunc: func(ctx context.Context, in *runmv1.CloseConsoleRequest, opts ...grpc.CallOption) (*runmv1.CloseConsoleResponse, error) {
//				panic("mock out the CloseConsole method")
//			},
//			CloseIOFunc: func(ctx context.Context, in *runmv1.CloseIORequest, opts ...grpc.CallOption) (*runmv1.CloseIOResponse, error) {
//				panic("mock out the CloseIO method")
//			},
//			CloseSocketFunc: func(ctx context.Context, in *runmv1.CloseSocketRequest, opts ...grpc.CallOption) (*runmv1.CloseSocketResponse, error) {
//				panic("mock out the CloseSocket method")
//			},
//			CloseSocketsFunc: func(ctx context.Context, in *runmv1.CloseSocketsRequest, opts ...grpc.CallOption) (*runmv1.CloseSocketsResponse, error) {
//				panic("mock out the CloseSockets method")
//			},
//			DialOpenListenerFunc: func(ctx context.Context, in *runmv1.DialOpenListenerRequest, opts ...grpc.CallOption) (*runmv1.DialOpenListenerResponse, error) {
//				panic("mock out the DialOpenListener method")
//			},
//		}
//
//		// use mockedSocketAllocatorServiceClient in code that requires runmv1.SocketAllocatorServiceClient
//		// and then make assertions.
//
//	}
type MockSocketAllocatorServiceClient struct {
	// AllocateConsoleFunc mocks the AllocateConsole method.
	AllocateConsoleFunc func(ctx context.Context, in *runmv1.AllocateConsoleRequest, opts ...grpc.CallOption) (*runmv1.AllocateConsoleResponse, error)

	// AllocateIOFunc mocks the AllocateIO method.
	AllocateIOFunc func(ctx context.Context, in *runmv1.AllocateIORequest, opts ...grpc.CallOption) (*runmv1.AllocateIOResponse, error)

	// AllocateSocketStreamFunc mocks the AllocateSocketStream method.
	AllocateSocketStreamFunc func(ctx context.Context, in *runmv1.AllocateSocketStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runmv1.AllocateSocketStreamResponse], error)

	// AllocateSocketsFunc mocks the AllocateSockets method.
	AllocateSocketsFunc func(ctx context.Context, in *runmv1.AllocateSocketsRequest, opts ...grpc.CallOption) (*runmv1.AllocateSocketsResponse, error)

	// BindConsoleToSocketFunc mocks the BindConsoleToSocket method.
	BindConsoleToSocketFunc func(ctx context.Context, in *runmv1.BindConsoleToSocketRequest, opts ...grpc.CallOption) (*runmv1.BindConsoleToSocketResponse, error)

	// BindIOToSocketsFunc mocks the BindIOToSockets method.
	BindIOToSocketsFunc func(ctx context.Context, in *runmv1.BindIOToSocketsRequest, opts ...grpc.CallOption) (*runmv1.BindIOToSocketsResponse, error)

	// CloseConsoleFunc mocks the CloseConsole method.
	CloseConsoleFunc func(ctx context.Context, in *runmv1.CloseConsoleRequest, opts ...grpc.CallOption) (*runmv1.CloseConsoleResponse, error)

	// CloseIOFunc mocks the CloseIO method.
	CloseIOFunc func(ctx context.Context, in *runmv1.CloseIORequest, opts ...grpc.CallOption) (*runmv1.CloseIOResponse, error)

	// CloseSocketFunc mocks the CloseSocket method.
	CloseSocketFunc func(ctx context.Context, in *runmv1.CloseSocketRequest, opts ...grpc.CallOption) (*runmv1.CloseSocketResponse, error)

	// CloseSocketsFunc mocks the CloseSockets method.
	CloseSocketsFunc func(ctx context.Context, in *runmv1.CloseSocketsRequest, opts ...grpc.CallOption) (*runmv1.CloseSocketsResponse, error)

	// DialOpenListenerFunc mocks the DialOpenListener method.
	DialOpenListenerFunc func(ctx context.Context, in *runmv1.DialOpenListenerRequest, opts ...grpc.CallOption) (*runmv1.DialOpenListenerResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// AllocateConsole holds details about calls to the AllocateConsole method.
		AllocateConsole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.AllocateConsoleRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// AllocateIO holds details about calls to the AllocateIO method.
		AllocateIO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.AllocateIORequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// AllocateSocketStream holds details about calls to the AllocateSocketStream method.
		AllocateSocketStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.AllocateSocketStreamRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// AllocateSockets holds details about calls to the AllocateSockets method.
		AllocateSockets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.AllocateSocketsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// BindConsoleToSocket holds details about calls to the BindConsoleToSocket method.
		BindConsoleToSocket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.BindConsoleToSocketRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// BindIOToSockets holds details about calls to the BindIOToSockets method.
		BindIOToSockets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.BindIOToSocketsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// CloseConsole holds details about calls to the CloseConsole method.
		CloseConsole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.CloseConsoleRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// CloseIO holds details about calls to the CloseIO method.
		CloseIO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.CloseIORequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// CloseSocket holds details about calls to the CloseSocket method.
		CloseSocket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.CloseSocketRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// CloseSockets holds details about calls to the CloseSockets method.
		CloseSockets []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.CloseSocketsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// DialOpenListener holds details about calls to the DialOpenListener method.
		DialOpenListener []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.DialOpenListenerRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockAllocateConsole      sync.RWMutex
	lockAllocateIO           sync.RWMutex
	lockAllocateSocketStream sync.RWMutex
	lockAllocateSockets      sync.RWMutex
	lockBindConsoleToSocket  sync.RWMutex
	lockBindIOToSockets      sync.RWMutex
	lockCloseConsole         sync.RWMutex
	lockCloseIO              sync.RWMutex
	lockCloseSocket          sync.RWMutex
	lockCloseSockets         sync.RWMutex
	lockDialOpenListener     sync.RWMutex
}

// AllocateConsole calls AllocateConsoleFunc.
func (mock *MockSocketAllocatorServiceClient) AllocateConsole(ctx context.Context, in *runmv1.AllocateConsoleRequest, opts ...grpc.CallOption) (*runmv1.AllocateConsoleResponse, error) {
	if mock.AllocateConsoleFunc == nil {
		panic("MockSocketAllocatorServiceClient.AllocateConsoleFunc: method is nil but SocketAllocatorServiceClient.AllocateConsole was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.AllocateConsoleRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockAllocateConsole.Lock()
	mock.calls.AllocateConsole = append(mock.calls.AllocateConsole, callInfo)
	mock.lockAllocateConsole.Unlock()
	return mock.AllocateConsoleFunc(ctx, in, opts...)
}

// AllocateConsoleCalls gets all the calls that were made to AllocateConsole.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.AllocateConsoleCalls())
func (mock *MockSocketAllocatorServiceClient) AllocateConsoleCalls() []struct {
	Ctx  context.Context
	In   *runmv1.AllocateConsoleRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.AllocateConsoleRequest
		Opts []grpc.CallOption
	}
	mock.lockAllocateConsole.RLock()
	calls = mock.calls.AllocateConsole
	mock.lockAllocateConsole.RUnlock()
	return calls
}

// AllocateIO calls AllocateIOFunc.
func (mock *MockSocketAllocatorServiceClient) AllocateIO(ctx context.Context, in *runmv1.AllocateIORequest, opts ...grpc.CallOption) (*runmv1.AllocateIOResponse, error) {
	if mock.AllocateIOFunc == nil {
		panic("MockSocketAllocatorServiceClient.AllocateIOFunc: method is nil but SocketAllocatorServiceClient.AllocateIO was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.AllocateIORequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockAllocateIO.Lock()
	mock.calls.AllocateIO = append(mock.calls.AllocateIO, callInfo)
	mock.lockAllocateIO.Unlock()
	return mock.AllocateIOFunc(ctx, in, opts...)
}

// AllocateIOCalls gets all the calls that were made to AllocateIO.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.AllocateIOCalls())
func (mock *MockSocketAllocatorServiceClient) AllocateIOCalls() []struct {
	Ctx  context.Context
	In   *runmv1.AllocateIORequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.AllocateIORequest
		Opts []grpc.CallOption
	}
	mock.lockAllocateIO.RLock()
	calls = mock.calls.AllocateIO
	mock.lockAllocateIO.RUnlock()
	return calls
}

// AllocateSocketStream calls AllocateSocketStreamFunc.
func (mock *MockSocketAllocatorServiceClient) AllocateSocketStream(ctx context.Context, in *runmv1.AllocateSocketStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runmv1.AllocateSocketStreamResponse], error) {
	if mock.AllocateSocketStreamFunc == nil {
		panic("MockSocketAllocatorServiceClient.AllocateSocketStreamFunc: method is nil but SocketAllocatorServiceClient.AllocateSocketStream was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.AllocateSocketStreamRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockAllocateSocketStream.Lock()
	mock.calls.AllocateSocketStream = append(mock.calls.AllocateSocketStream, callInfo)
	mock.lockAllocateSocketStream.Unlock()
	return mock.AllocateSocketStreamFunc(ctx, in, opts...)
}

// AllocateSocketStreamCalls gets all the calls that were made to AllocateSocketStream.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.AllocateSocketStreamCalls())
func (mock *MockSocketAllocatorServiceClient) AllocateSocketStreamCalls() []struct {
	Ctx  context.Context
	In   *runmv1.AllocateSocketStreamRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.AllocateSocketStreamRequest
		Opts []grpc.CallOption
	}
	mock.lockAllocateSocketStream.RLock()
	calls = mock.calls.AllocateSocketStream
	mock.lockAllocateSocketStream.RUnlock()
	return calls
}

// AllocateSockets calls AllocateSocketsFunc.
func (mock *MockSocketAllocatorServiceClient) AllocateSockets(ctx context.Context, in *runmv1.AllocateSocketsRequest, opts ...grpc.CallOption) (*runmv1.AllocateSocketsResponse, error) {
	if mock.AllocateSocketsFunc == nil {
		panic("MockSocketAllocatorServiceClient.AllocateSocketsFunc: method is nil but SocketAllocatorServiceClient.AllocateSockets was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.AllocateSocketsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockAllocateSockets.Lock()
	mock.calls.AllocateSockets = append(mock.calls.AllocateSockets, callInfo)
	mock.lockAllocateSockets.Unlock()
	return mock.AllocateSocketsFunc(ctx, in, opts...)
}

// AllocateSocketsCalls gets all the calls that were made to AllocateSockets.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.AllocateSocketsCalls())
func (mock *MockSocketAllocatorServiceClient) AllocateSocketsCalls() []struct {
	Ctx  context.Context
	In   *runmv1.AllocateSocketsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.AllocateSocketsRequest
		Opts []grpc.CallOption
	}
	mock.lockAllocateSockets.RLock()
	calls = mock.calls.AllocateSockets
	mock.lockAllocateSockets.RUnlock()
	return calls
}

// BindConsoleToSocket calls BindConsoleToSocketFunc.
func (mock *MockSocketAllocatorServiceClient) BindConsoleToSocket(ctx context.Context, in *runmv1.BindConsoleToSocketRequest, opts ...grpc.CallOption) (*runmv1.BindConsoleToSocketResponse, error) {
	if mock.BindConsoleToSocketFunc == nil {
		panic("MockSocketAllocatorServiceClient.BindConsoleToSocketFunc: method is nil but SocketAllocatorServiceClient.BindConsoleToSocket was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.BindConsoleToSocketRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockBindConsoleToSocket.Lock()
	mock.calls.BindConsoleToSocket = append(mock.calls.BindConsoleToSocket, callInfo)
	mock.lockBindConsoleToSocket.Unlock()
	return mock.BindConsoleToSocketFunc(ctx, in, opts...)
}

// BindConsoleToSocketCalls gets all the calls that were made to BindConsoleToSocket.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.BindConsoleToSocketCalls())
func (mock *MockSocketAllocatorServiceClient) BindConsoleToSocketCalls() []struct {
	Ctx  context.Context
	In   *runmv1.BindConsoleToSocketRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.BindConsoleToSocketRequest
		Opts []grpc.CallOption
	}
	mock.lockBindConsoleToSocket.RLock()
	calls = mock.calls.BindConsoleToSocket
	mock.lockBindConsoleToSocket.RUnlock()
	return calls
}

// BindIOToSockets calls BindIOToSocketsFunc.
func (mock *MockSocketAllocatorServiceClient) BindIOToSockets(ctx context.Context, in *runmv1.BindIOToSocketsRequest, opts ...grpc.CallOption) (*runmv1.BindIOToSocketsResponse, error) {
	if mock.BindIOToSocketsFunc == nil {
		panic("MockSocketAllocatorServiceClient.BindIOToSocketsFunc: method is nil but SocketAllocatorServiceClient.BindIOToSockets was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.BindIOToSocketsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockBindIOToSockets.Lock()
	mock.calls.BindIOToSockets = append(mock.calls.BindIOToSockets, callInfo)
	mock.lockBindIOToSockets.Unlock()
	return mock.BindIOToSocketsFunc(ctx, in, opts...)
}

// BindIOToSocketsCalls gets all the calls that were made to BindIOToSockets.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.BindIOToSocketsCalls())
func (mock *MockSocketAllocatorServiceClient) BindIOToSocketsCalls() []struct {
	Ctx  context.Context
	In   *runmv1.BindIOToSocketsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.BindIOToSocketsRequest
		Opts []grpc.CallOption
	}
	mock.lockBindIOToSockets.RLock()
	calls = mock.calls.BindIOToSockets
	mock.lockBindIOToSockets.RUnlock()
	return calls
}

// CloseConsole calls CloseConsoleFunc.
func (mock *MockSocketAllocatorServiceClient) CloseConsole(ctx context.Context, in *runmv1.CloseConsoleRequest, opts ...grpc.CallOption) (*runmv1.CloseConsoleResponse, error) {
	if mock.CloseConsoleFunc == nil {
		panic("MockSocketAllocatorServiceClient.CloseConsoleFunc: method is nil but SocketAllocatorServiceClient.CloseConsole was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.CloseConsoleRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCloseConsole.Lock()
	mock.calls.CloseConsole = append(mock.calls.CloseConsole, callInfo)
	mock.lockCloseConsole.Unlock()
	return mock.CloseConsoleFunc(ctx, in, opts...)
}

// CloseConsoleCalls gets all the calls that were made to CloseConsole.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.CloseConsoleCalls())
func (mock *MockSocketAllocatorServiceClient) CloseConsoleCalls() []struct {
	Ctx  context.Context
	In   *runmv1.CloseConsoleRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.CloseConsoleRequest
		Opts []grpc.CallOption
	}
	mock.lockCloseConsole.RLock()
	calls = mock.calls.CloseConsole
	mock.lockCloseConsole.RUnlock()
	return calls
}

// CloseIO calls CloseIOFunc.
func (mock *MockSocketAllocatorServiceClient) CloseIO(ctx context.Context, in *runmv1.CloseIORequest, opts ...grpc.CallOption) (*runmv1.CloseIOResponse, error) {
	if mock.CloseIOFunc == nil {
		panic("MockSocketAllocatorServiceClient.CloseIOFunc: method is nil but SocketAllocatorServiceClient.CloseIO was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.CloseIORequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCloseIO.Lock()
	mock.calls.CloseIO = append(mock.calls.CloseIO, callInfo)
	mock.lockCloseIO.Unlock()
	return mock.CloseIOFunc(ctx, in, opts...)
}

// CloseIOCalls gets all the calls that were made to CloseIO.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.CloseIOCalls())
func (mock *MockSocketAllocatorServiceClient) CloseIOCalls() []struct {
	Ctx  context.Context
	In   *runmv1.CloseIORequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.CloseIORequest
		Opts []grpc.CallOption
	}
	mock.lockCloseIO.RLock()
	calls = mock.calls.CloseIO
	mock.lockCloseIO.RUnlock()
	return calls
}

// CloseSocket calls CloseSocketFunc.
func (mock *MockSocketAllocatorServiceClient) CloseSocket(ctx context.Context, in *runmv1.CloseSocketRequest, opts ...grpc.CallOption) (*runmv1.CloseSocketResponse, error) {
	if mock.CloseSocketFunc == nil {
		panic("MockSocketAllocatorServiceClient.CloseSocketFunc: method is nil but SocketAllocatorServiceClient.CloseSocket was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.CloseSocketRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCloseSocket.Lock()
	mock.calls.CloseSocket = append(mock.calls.CloseSocket, callInfo)
	mock.lockCloseSocket.Unlock()
	return mock.CloseSocketFunc(ctx, in, opts...)
}

// CloseSocketCalls gets all the calls that were made to CloseSocket.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.CloseSocketCalls())
func (mock *MockSocketAllocatorServiceClient) CloseSocketCalls() []struct {
	Ctx  context.Context
	In   *runmv1.CloseSocketRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.CloseSocketRequest
		Opts []grpc.CallOption
	}
	mock.lockCloseSocket.RLock()
	calls = mock.calls.CloseSocket
	mock.lockCloseSocket.RUnlock()
	return calls
}

// CloseSockets calls CloseSocketsFunc.
func (mock *MockSocketAllocatorServiceClient) CloseSockets(ctx context.Context, in *runmv1.CloseSocketsRequest, opts ...grpc.CallOption) (*runmv1.CloseSocketsResponse, error) {
	if mock.CloseSocketsFunc == nil {
		panic("MockSocketAllocatorServiceClient.CloseSocketsFunc: method is nil but SocketAllocatorServiceClient.CloseSockets was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.CloseSocketsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCloseSockets.Lock()
	mock.calls.CloseSockets = append(mock.calls.CloseSockets, callInfo)
	mock.lockCloseSockets.Unlock()
	return mock.CloseSocketsFunc(ctx, in, opts...)
}

// CloseSocketsCalls gets all the calls that were made to CloseSockets.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.CloseSocketsCalls())
func (mock *MockSocketAllocatorServiceClient) CloseSocketsCalls() []struct {
	Ctx  context.Context
	In   *runmv1.CloseSocketsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.CloseSocketsRequest
		Opts []grpc.CallOption
	}
	mock.lockCloseSockets.RLock()
	calls = mock.calls.CloseSockets
	mock.lockCloseSockets.RUnlock()
	return calls
}

// DialOpenListener calls DialOpenListenerFunc.
func (mock *MockSocketAllocatorServiceClient) DialOpenListener(ctx context.Context, in *runmv1.DialOpenListenerRequest, opts ...grpc.CallOption) (*runmv1.DialOpenListenerResponse, error) {
	if mock.DialOpenListenerFunc == nil {
		panic("MockSocketAllocatorServiceClient.DialOpenListenerFunc: method is nil but SocketAllocatorServiceClient.DialOpenListener was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.DialOpenListenerRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockDialOpenListener.Lock()
	mock.calls.DialOpenListener = append(mock.calls.DialOpenListener, callInfo)
	mock.lockDialOpenListener.Unlock()
	return mock.DialOpenListenerFunc(ctx, in, opts...)
}

// DialOpenListenerCalls gets all the calls that were made to DialOpenListener.
// Check the length with:
//
//	len(mockedSocketAllocatorServiceClient.DialOpenListenerCalls())
func (mock *MockSocketAllocatorServiceClient) DialOpenListenerCalls() []struct {
	Ctx  context.Context
	In   *runmv1.DialOpenListenerRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.DialOpenListenerRequest
		Opts []grpc.CallOption
	}
	mock.lockDialOpenListener.RLock()
	calls = mock.calls.DialOpenListener
	mock.lockDialOpenListener.RUnlock()
	return calls
}
