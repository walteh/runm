// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockrunvv1

import (
	"context"
	"sync"

	"github.com/walteh/runv/proto/v1"
	"google.golang.org/grpc"
)

// Ensure that MockRuncServiceClient does implement runvv1.RuncServiceClient.
// If this is not the case, regenerate this file with mockery.
var _ runvv1.RuncServiceClient = &MockRuncServiceClient{}

// MockRuncServiceClient is a mock implementation of runvv1.RuncServiceClient.
//
//	func TestSomethingThatUsesRuncServiceClient(t *testing.T) {
//
//		// make and configure a mocked runvv1.RuncServiceClient
//		mockedRuncServiceClient := &MockRuncServiceClient{
//			CheckpointFunc: func(ctx context.Context, in *runvv1.RuncCheckpointRequest, opts ...grpc.CallOption) (*runvv1.RuncCheckpointResponse, error) {
//				panic("mock out the Checkpoint method")
//			},
//			CreateFunc: func(ctx context.Context, in *runvv1.RuncCreateRequest, opts ...grpc.CallOption) (*runvv1.RuncCreateResponse, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, in *runvv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runvv1.RuncDeleteResponse, error) {
//				panic("mock out the Delete method")
//			},
//			EventsFunc: func(ctx context.Context, in *runvv1.RuncEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runvv1.RuncEvent], error) {
//				panic("mock out the Events method")
//			},
//			ExecFunc: func(ctx context.Context, in *runvv1.RuncExecRequest, opts ...grpc.CallOption) (*runvv1.RuncExecResponse, error) {
//				panic("mock out the Exec method")
//			},
//			KillFunc: func(ctx context.Context, in *runvv1.RuncKillRequest, opts ...grpc.CallOption) (*runvv1.RuncKillResponse, error) {
//				panic("mock out the Kill method")
//			},
//			ListFunc: func(ctx context.Context, in *runvv1.RuncListRequest, opts ...grpc.CallOption) (*runvv1.RuncListResponse, error) {
//				panic("mock out the List method")
//			},
//			LogFilePathFunc: func(ctx context.Context, in *runvv1.RuncLogFilePathRequest, opts ...grpc.CallOption) (*runvv1.RuncLogFilePathResponse, error) {
//				panic("mock out the LogFilePath method")
//			},
//			PauseFunc: func(ctx context.Context, in *runvv1.RuncPauseRequest, opts ...grpc.CallOption) (*runvv1.RuncPauseResponse, error) {
//				panic("mock out the Pause method")
//			},
//			PingFunc: func(ctx context.Context, in *runvv1.PingRequest, opts ...grpc.CallOption) (*runvv1.PingResponse, error) {
//				panic("mock out the Ping method")
//			},
//			PsFunc: func(ctx context.Context, in *runvv1.RuncPsRequest, opts ...grpc.CallOption) (*runvv1.RuncPsResponse, error) {
//				panic("mock out the Ps method")
//			},
//			RestoreFunc: func(ctx context.Context, in *runvv1.RuncRestoreRequest, opts ...grpc.CallOption) (*runvv1.RuncRestoreResponse, error) {
//				panic("mock out the Restore method")
//			},
//			ResumeFunc: func(ctx context.Context, in *runvv1.RuncResumeRequest, opts ...grpc.CallOption) (*runvv1.RuncResumeResponse, error) {
//				panic("mock out the Resume method")
//			},
//			RunFunc: func(ctx context.Context, in *runvv1.RuncRunRequest, opts ...grpc.CallOption) (*runvv1.RuncRunResponse, error) {
//				panic("mock out the Run method")
//			},
//			StartFunc: func(ctx context.Context, in *runvv1.RuncStartRequest, opts ...grpc.CallOption) (*runvv1.RuncStartResponse, error) {
//				panic("mock out the Start method")
//			},
//			StateFunc: func(ctx context.Context, in *runvv1.RuncStateRequest, opts ...grpc.CallOption) (*runvv1.RuncStateResponse, error) {
//				panic("mock out the State method")
//			},
//			StatsFunc: func(ctx context.Context, in *runvv1.RuncStatsRequest, opts ...grpc.CallOption) (*runvv1.RuncStatsResponse, error) {
//				panic("mock out the Stats method")
//			},
//			TopFunc: func(ctx context.Context, in *runvv1.RuncTopRequest, opts ...grpc.CallOption) (*runvv1.RuncTopResponse, error) {
//				panic("mock out the Top method")
//			},
//			UpdateFunc: func(ctx context.Context, in *runvv1.RuncUpdateRequest, opts ...grpc.CallOption) (*runvv1.RuncUpdateResponse, error) {
//				panic("mock out the Update method")
//			},
//			VersionFunc: func(ctx context.Context, in *runvv1.RuncVersionRequest, opts ...grpc.CallOption) (*runvv1.RuncVersionResponse, error) {
//				panic("mock out the Version method")
//			},
//		}
//
//		// use mockedRuncServiceClient in code that requires runvv1.RuncServiceClient
//		// and then make assertions.
//
//	}
type MockRuncServiceClient struct {
	// CheckpointFunc mocks the Checkpoint method.
	CheckpointFunc func(ctx context.Context, in *runvv1.RuncCheckpointRequest, opts ...grpc.CallOption) (*runvv1.RuncCheckpointResponse, error)

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, in *runvv1.RuncCreateRequest, opts ...grpc.CallOption) (*runvv1.RuncCreateResponse, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, in *runvv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runvv1.RuncDeleteResponse, error)

	// EventsFunc mocks the Events method.
	EventsFunc func(ctx context.Context, in *runvv1.RuncEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runvv1.RuncEvent], error)

	// ExecFunc mocks the Exec method.
	ExecFunc func(ctx context.Context, in *runvv1.RuncExecRequest, opts ...grpc.CallOption) (*runvv1.RuncExecResponse, error)

	// KillFunc mocks the Kill method.
	KillFunc func(ctx context.Context, in *runvv1.RuncKillRequest, opts ...grpc.CallOption) (*runvv1.RuncKillResponse, error)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, in *runvv1.RuncListRequest, opts ...grpc.CallOption) (*runvv1.RuncListResponse, error)

	// LogFilePathFunc mocks the LogFilePath method.
	LogFilePathFunc func(ctx context.Context, in *runvv1.RuncLogFilePathRequest, opts ...grpc.CallOption) (*runvv1.RuncLogFilePathResponse, error)

	// PauseFunc mocks the Pause method.
	PauseFunc func(ctx context.Context, in *runvv1.RuncPauseRequest, opts ...grpc.CallOption) (*runvv1.RuncPauseResponse, error)

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context, in *runvv1.PingRequest, opts ...grpc.CallOption) (*runvv1.PingResponse, error)

	// PsFunc mocks the Ps method.
	PsFunc func(ctx context.Context, in *runvv1.RuncPsRequest, opts ...grpc.CallOption) (*runvv1.RuncPsResponse, error)

	// RestoreFunc mocks the Restore method.
	RestoreFunc func(ctx context.Context, in *runvv1.RuncRestoreRequest, opts ...grpc.CallOption) (*runvv1.RuncRestoreResponse, error)

	// ResumeFunc mocks the Resume method.
	ResumeFunc func(ctx context.Context, in *runvv1.RuncResumeRequest, opts ...grpc.CallOption) (*runvv1.RuncResumeResponse, error)

	// RunFunc mocks the Run method.
	RunFunc func(ctx context.Context, in *runvv1.RuncRunRequest, opts ...grpc.CallOption) (*runvv1.RuncRunResponse, error)

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, in *runvv1.RuncStartRequest, opts ...grpc.CallOption) (*runvv1.RuncStartResponse, error)

	// StateFunc mocks the State method.
	StateFunc func(ctx context.Context, in *runvv1.RuncStateRequest, opts ...grpc.CallOption) (*runvv1.RuncStateResponse, error)

	// StatsFunc mocks the Stats method.
	StatsFunc func(ctx context.Context, in *runvv1.RuncStatsRequest, opts ...grpc.CallOption) (*runvv1.RuncStatsResponse, error)

	// TopFunc mocks the Top method.
	TopFunc func(ctx context.Context, in *runvv1.RuncTopRequest, opts ...grpc.CallOption) (*runvv1.RuncTopResponse, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, in *runvv1.RuncUpdateRequest, opts ...grpc.CallOption) (*runvv1.RuncUpdateResponse, error)

	// VersionFunc mocks the Version method.
	VersionFunc func(ctx context.Context, in *runvv1.RuncVersionRequest, opts ...grpc.CallOption) (*runvv1.RuncVersionResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Checkpoint holds details about calls to the Checkpoint method.
		Checkpoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncCheckpointRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncCreateRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncDeleteRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Events holds details about calls to the Events method.
		Events []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncEventsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncExecRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Kill holds details about calls to the Kill method.
		Kill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncKillRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncListRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// LogFilePath holds details about calls to the LogFilePath method.
		LogFilePath []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncLogFilePathRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Pause holds details about calls to the Pause method.
		Pause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncPauseRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.PingRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Ps holds details about calls to the Ps method.
		Ps []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncPsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Restore holds details about calls to the Restore method.
		Restore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncRestoreRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Resume holds details about calls to the Resume method.
		Resume []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncResumeRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncRunRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncStartRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// State holds details about calls to the State method.
		State []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncStateRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncStatsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Top holds details about calls to the Top method.
		Top []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncTopRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncUpdateRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Version holds details about calls to the Version method.
		Version []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncVersionRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockCheckpoint  sync.RWMutex
	lockCreate      sync.RWMutex
	lockDelete      sync.RWMutex
	lockEvents      sync.RWMutex
	lockExec        sync.RWMutex
	lockKill        sync.RWMutex
	lockList        sync.RWMutex
	lockLogFilePath sync.RWMutex
	lockPause       sync.RWMutex
	lockPing        sync.RWMutex
	lockPs          sync.RWMutex
	lockRestore     sync.RWMutex
	lockResume      sync.RWMutex
	lockRun         sync.RWMutex
	lockStart       sync.RWMutex
	lockState       sync.RWMutex
	lockStats       sync.RWMutex
	lockTop         sync.RWMutex
	lockUpdate      sync.RWMutex
	lockVersion     sync.RWMutex
}

// Checkpoint calls CheckpointFunc.
func (mock *MockRuncServiceClient) Checkpoint(ctx context.Context, in *runvv1.RuncCheckpointRequest, opts ...grpc.CallOption) (*runvv1.RuncCheckpointResponse, error) {
	if mock.CheckpointFunc == nil {
		panic("MockRuncServiceClient.CheckpointFunc: method is nil but RuncServiceClient.Checkpoint was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncCheckpointRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCheckpoint.Lock()
	mock.calls.Checkpoint = append(mock.calls.Checkpoint, callInfo)
	mock.lockCheckpoint.Unlock()
	return mock.CheckpointFunc(ctx, in, opts...)
}

// CheckpointCalls gets all the calls that were made to Checkpoint.
// Check the length with:
//
//	len(mockedRuncServiceClient.CheckpointCalls())
func (mock *MockRuncServiceClient) CheckpointCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncCheckpointRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncCheckpointRequest
		Opts []grpc.CallOption
	}
	mock.lockCheckpoint.RLock()
	calls = mock.calls.Checkpoint
	mock.lockCheckpoint.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *MockRuncServiceClient) Create(ctx context.Context, in *runvv1.RuncCreateRequest, opts ...grpc.CallOption) (*runvv1.RuncCreateResponse, error) {
	if mock.CreateFunc == nil {
		panic("MockRuncServiceClient.CreateFunc: method is nil but RuncServiceClient.Create was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncCreateRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, in, opts...)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedRuncServiceClient.CreateCalls())
func (mock *MockRuncServiceClient) CreateCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncCreateRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncCreateRequest
		Opts []grpc.CallOption
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *MockRuncServiceClient) Delete(ctx context.Context, in *runvv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runvv1.RuncDeleteResponse, error) {
	if mock.DeleteFunc == nil {
		panic("MockRuncServiceClient.DeleteFunc: method is nil but RuncServiceClient.Delete was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncDeleteRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, in, opts...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedRuncServiceClient.DeleteCalls())
func (mock *MockRuncServiceClient) DeleteCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncDeleteRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncDeleteRequest
		Opts []grpc.CallOption
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Events calls EventsFunc.
func (mock *MockRuncServiceClient) Events(ctx context.Context, in *runvv1.RuncEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[runvv1.RuncEvent], error) {
	if mock.EventsFunc == nil {
		panic("MockRuncServiceClient.EventsFunc: method is nil but RuncServiceClient.Events was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncEventsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockEvents.Lock()
	mock.calls.Events = append(mock.calls.Events, callInfo)
	mock.lockEvents.Unlock()
	return mock.EventsFunc(ctx, in, opts...)
}

// EventsCalls gets all the calls that were made to Events.
// Check the length with:
//
//	len(mockedRuncServiceClient.EventsCalls())
func (mock *MockRuncServiceClient) EventsCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncEventsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncEventsRequest
		Opts []grpc.CallOption
	}
	mock.lockEvents.RLock()
	calls = mock.calls.Events
	mock.lockEvents.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *MockRuncServiceClient) Exec(ctx context.Context, in *runvv1.RuncExecRequest, opts ...grpc.CallOption) (*runvv1.RuncExecResponse, error) {
	if mock.ExecFunc == nil {
		panic("MockRuncServiceClient.ExecFunc: method is nil but RuncServiceClient.Exec was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncExecRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(ctx, in, opts...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedRuncServiceClient.ExecCalls())
func (mock *MockRuncServiceClient) ExecCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncExecRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncExecRequest
		Opts []grpc.CallOption
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// Kill calls KillFunc.
func (mock *MockRuncServiceClient) Kill(ctx context.Context, in *runvv1.RuncKillRequest, opts ...grpc.CallOption) (*runvv1.RuncKillResponse, error) {
	if mock.KillFunc == nil {
		panic("MockRuncServiceClient.KillFunc: method is nil but RuncServiceClient.Kill was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncKillRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockKill.Lock()
	mock.calls.Kill = append(mock.calls.Kill, callInfo)
	mock.lockKill.Unlock()
	return mock.KillFunc(ctx, in, opts...)
}

// KillCalls gets all the calls that were made to Kill.
// Check the length with:
//
//	len(mockedRuncServiceClient.KillCalls())
func (mock *MockRuncServiceClient) KillCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncKillRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncKillRequest
		Opts []grpc.CallOption
	}
	mock.lockKill.RLock()
	calls = mock.calls.Kill
	mock.lockKill.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *MockRuncServiceClient) List(ctx context.Context, in *runvv1.RuncListRequest, opts ...grpc.CallOption) (*runvv1.RuncListResponse, error) {
	if mock.ListFunc == nil {
		panic("MockRuncServiceClient.ListFunc: method is nil but RuncServiceClient.List was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncListRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, in, opts...)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedRuncServiceClient.ListCalls())
func (mock *MockRuncServiceClient) ListCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncListRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncListRequest
		Opts []grpc.CallOption
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// LogFilePath calls LogFilePathFunc.
func (mock *MockRuncServiceClient) LogFilePath(ctx context.Context, in *runvv1.RuncLogFilePathRequest, opts ...grpc.CallOption) (*runvv1.RuncLogFilePathResponse, error) {
	if mock.LogFilePathFunc == nil {
		panic("MockRuncServiceClient.LogFilePathFunc: method is nil but RuncServiceClient.LogFilePath was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncLogFilePathRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockLogFilePath.Lock()
	mock.calls.LogFilePath = append(mock.calls.LogFilePath, callInfo)
	mock.lockLogFilePath.Unlock()
	return mock.LogFilePathFunc(ctx, in, opts...)
}

// LogFilePathCalls gets all the calls that were made to LogFilePath.
// Check the length with:
//
//	len(mockedRuncServiceClient.LogFilePathCalls())
func (mock *MockRuncServiceClient) LogFilePathCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncLogFilePathRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncLogFilePathRequest
		Opts []grpc.CallOption
	}
	mock.lockLogFilePath.RLock()
	calls = mock.calls.LogFilePath
	mock.lockLogFilePath.RUnlock()
	return calls
}

// Pause calls PauseFunc.
func (mock *MockRuncServiceClient) Pause(ctx context.Context, in *runvv1.RuncPauseRequest, opts ...grpc.CallOption) (*runvv1.RuncPauseResponse, error) {
	if mock.PauseFunc == nil {
		panic("MockRuncServiceClient.PauseFunc: method is nil but RuncServiceClient.Pause was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncPauseRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPause.Lock()
	mock.calls.Pause = append(mock.calls.Pause, callInfo)
	mock.lockPause.Unlock()
	return mock.PauseFunc(ctx, in, opts...)
}

// PauseCalls gets all the calls that were made to Pause.
// Check the length with:
//
//	len(mockedRuncServiceClient.PauseCalls())
func (mock *MockRuncServiceClient) PauseCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncPauseRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncPauseRequest
		Opts []grpc.CallOption
	}
	mock.lockPause.RLock()
	calls = mock.calls.Pause
	mock.lockPause.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *MockRuncServiceClient) Ping(ctx context.Context, in *runvv1.PingRequest, opts ...grpc.CallOption) (*runvv1.PingResponse, error) {
	if mock.PingFunc == nil {
		panic("MockRuncServiceClient.PingFunc: method is nil but RuncServiceClient.Ping was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.PingRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx, in, opts...)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedRuncServiceClient.PingCalls())
func (mock *MockRuncServiceClient) PingCalls() []struct {
	Ctx  context.Context
	In   *runvv1.PingRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.PingRequest
		Opts []grpc.CallOption
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// Ps calls PsFunc.
func (mock *MockRuncServiceClient) Ps(ctx context.Context, in *runvv1.RuncPsRequest, opts ...grpc.CallOption) (*runvv1.RuncPsResponse, error) {
	if mock.PsFunc == nil {
		panic("MockRuncServiceClient.PsFunc: method is nil but RuncServiceClient.Ps was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncPsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPs.Lock()
	mock.calls.Ps = append(mock.calls.Ps, callInfo)
	mock.lockPs.Unlock()
	return mock.PsFunc(ctx, in, opts...)
}

// PsCalls gets all the calls that were made to Ps.
// Check the length with:
//
//	len(mockedRuncServiceClient.PsCalls())
func (mock *MockRuncServiceClient) PsCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncPsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncPsRequest
		Opts []grpc.CallOption
	}
	mock.lockPs.RLock()
	calls = mock.calls.Ps
	mock.lockPs.RUnlock()
	return calls
}

// Restore calls RestoreFunc.
func (mock *MockRuncServiceClient) Restore(ctx context.Context, in *runvv1.RuncRestoreRequest, opts ...grpc.CallOption) (*runvv1.RuncRestoreResponse, error) {
	if mock.RestoreFunc == nil {
		panic("MockRuncServiceClient.RestoreFunc: method is nil but RuncServiceClient.Restore was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncRestoreRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockRestore.Lock()
	mock.calls.Restore = append(mock.calls.Restore, callInfo)
	mock.lockRestore.Unlock()
	return mock.RestoreFunc(ctx, in, opts...)
}

// RestoreCalls gets all the calls that were made to Restore.
// Check the length with:
//
//	len(mockedRuncServiceClient.RestoreCalls())
func (mock *MockRuncServiceClient) RestoreCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncRestoreRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncRestoreRequest
		Opts []grpc.CallOption
	}
	mock.lockRestore.RLock()
	calls = mock.calls.Restore
	mock.lockRestore.RUnlock()
	return calls
}

// Resume calls ResumeFunc.
func (mock *MockRuncServiceClient) Resume(ctx context.Context, in *runvv1.RuncResumeRequest, opts ...grpc.CallOption) (*runvv1.RuncResumeResponse, error) {
	if mock.ResumeFunc == nil {
		panic("MockRuncServiceClient.ResumeFunc: method is nil but RuncServiceClient.Resume was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncResumeRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockResume.Lock()
	mock.calls.Resume = append(mock.calls.Resume, callInfo)
	mock.lockResume.Unlock()
	return mock.ResumeFunc(ctx, in, opts...)
}

// ResumeCalls gets all the calls that were made to Resume.
// Check the length with:
//
//	len(mockedRuncServiceClient.ResumeCalls())
func (mock *MockRuncServiceClient) ResumeCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncResumeRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncResumeRequest
		Opts []grpc.CallOption
	}
	mock.lockResume.RLock()
	calls = mock.calls.Resume
	mock.lockResume.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *MockRuncServiceClient) Run(ctx context.Context, in *runvv1.RuncRunRequest, opts ...grpc.CallOption) (*runvv1.RuncRunResponse, error) {
	if mock.RunFunc == nil {
		panic("MockRuncServiceClient.RunFunc: method is nil but RuncServiceClient.Run was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncRunRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(ctx, in, opts...)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedRuncServiceClient.RunCalls())
func (mock *MockRuncServiceClient) RunCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncRunRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncRunRequest
		Opts []grpc.CallOption
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *MockRuncServiceClient) Start(ctx context.Context, in *runvv1.RuncStartRequest, opts ...grpc.CallOption) (*runvv1.RuncStartResponse, error) {
	if mock.StartFunc == nil {
		panic("MockRuncServiceClient.StartFunc: method is nil but RuncServiceClient.Start was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncStartRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, in, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedRuncServiceClient.StartCalls())
func (mock *MockRuncServiceClient) StartCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncStartRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncStartRequest
		Opts []grpc.CallOption
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// State calls StateFunc.
func (mock *MockRuncServiceClient) State(ctx context.Context, in *runvv1.RuncStateRequest, opts ...grpc.CallOption) (*runvv1.RuncStateResponse, error) {
	if mock.StateFunc == nil {
		panic("MockRuncServiceClient.StateFunc: method is nil but RuncServiceClient.State was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncStateRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockState.Lock()
	mock.calls.State = append(mock.calls.State, callInfo)
	mock.lockState.Unlock()
	return mock.StateFunc(ctx, in, opts...)
}

// StateCalls gets all the calls that were made to State.
// Check the length with:
//
//	len(mockedRuncServiceClient.StateCalls())
func (mock *MockRuncServiceClient) StateCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncStateRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncStateRequest
		Opts []grpc.CallOption
	}
	mock.lockState.RLock()
	calls = mock.calls.State
	mock.lockState.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *MockRuncServiceClient) Stats(ctx context.Context, in *runvv1.RuncStatsRequest, opts ...grpc.CallOption) (*runvv1.RuncStatsResponse, error) {
	if mock.StatsFunc == nil {
		panic("MockRuncServiceClient.StatsFunc: method is nil but RuncServiceClient.Stats was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncStatsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	return mock.StatsFunc(ctx, in, opts...)
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedRuncServiceClient.StatsCalls())
func (mock *MockRuncServiceClient) StatsCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncStatsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncStatsRequest
		Opts []grpc.CallOption
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// Top calls TopFunc.
func (mock *MockRuncServiceClient) Top(ctx context.Context, in *runvv1.RuncTopRequest, opts ...grpc.CallOption) (*runvv1.RuncTopResponse, error) {
	if mock.TopFunc == nil {
		panic("MockRuncServiceClient.TopFunc: method is nil but RuncServiceClient.Top was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncTopRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockTop.Lock()
	mock.calls.Top = append(mock.calls.Top, callInfo)
	mock.lockTop.Unlock()
	return mock.TopFunc(ctx, in, opts...)
}

// TopCalls gets all the calls that were made to Top.
// Check the length with:
//
//	len(mockedRuncServiceClient.TopCalls())
func (mock *MockRuncServiceClient) TopCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncTopRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncTopRequest
		Opts []grpc.CallOption
	}
	mock.lockTop.RLock()
	calls = mock.calls.Top
	mock.lockTop.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MockRuncServiceClient) Update(ctx context.Context, in *runvv1.RuncUpdateRequest, opts ...grpc.CallOption) (*runvv1.RuncUpdateResponse, error) {
	if mock.UpdateFunc == nil {
		panic("MockRuncServiceClient.UpdateFunc: method is nil but RuncServiceClient.Update was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncUpdateRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, in, opts...)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedRuncServiceClient.UpdateCalls())
func (mock *MockRuncServiceClient) UpdateCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncUpdateRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncUpdateRequest
		Opts []grpc.CallOption
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Version calls VersionFunc.
func (mock *MockRuncServiceClient) Version(ctx context.Context, in *runvv1.RuncVersionRequest, opts ...grpc.CallOption) (*runvv1.RuncVersionResponse, error) {
	if mock.VersionFunc == nil {
		panic("MockRuncServiceClient.VersionFunc: method is nil but RuncServiceClient.Version was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncVersionRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockVersion.Lock()
	mock.calls.Version = append(mock.calls.Version, callInfo)
	mock.lockVersion.Unlock()
	return mock.VersionFunc(ctx, in, opts...)
}

// VersionCalls gets all the calls that were made to Version.
// Check the length with:
//
//	len(mockedRuncServiceClient.VersionCalls())
func (mock *MockRuncServiceClient) VersionCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncVersionRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncVersionRequest
		Opts []grpc.CallOption
	}
	mock.lockVersion.RLock()
	calls = mock.calls.Version
	mock.lockVersion.RUnlock()
	return calls
}
