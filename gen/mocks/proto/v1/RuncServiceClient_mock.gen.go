// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockrunvv1

import (
	"context"
	"sync"

	"github.com/walteh/runv/proto/v1"
	"google.golang.org/grpc"
)

// Ensure that MockRuncServiceClient does implement runvv1.RuncServiceClient.
// If this is not the case, regenerate this file with mockery.
var _ runvv1.RuncServiceClient = &MockRuncServiceClient{}

// MockRuncServiceClient is a mock implementation of runvv1.RuncServiceClient.
//
//	func TestSomethingThatUsesRuncServiceClient(t *testing.T) {
//
//		// make and configure a mocked runvv1.RuncServiceClient
//		mockedRuncServiceClient := &MockRuncServiceClient{
//			CreateFunc: func(ctx context.Context, in *runvv1.RuncCreateRequest, opts ...grpc.CallOption) (*runvv1.RuncCreateResponse, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, in *runvv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runvv1.RuncDeleteResponse, error) {
//				panic("mock out the Delete method")
//			},
//			ExecFunc: func(ctx context.Context, in *runvv1.RuncExecRequest, opts ...grpc.CallOption) (*runvv1.RuncExecResponse, error) {
//				panic("mock out the Exec method")
//			},
//			KillFunc: func(ctx context.Context, in *runvv1.RuncKillRequest, opts ...grpc.CallOption) (*runvv1.RuncKillResponse, error) {
//				panic("mock out the Kill method")
//			},
//			ListFunc: func(ctx context.Context, in *runvv1.RuncListRequest, opts ...grpc.CallOption) (*runvv1.RuncListResponse, error) {
//				panic("mock out the List method")
//			},
//			PauseFunc: func(ctx context.Context, in *runvv1.RuncPauseRequest, opts ...grpc.CallOption) (*runvv1.RuncPauseResponse, error) {
//				panic("mock out the Pause method")
//			},
//			PingFunc: func(ctx context.Context, in *runvv1.PingRequest, opts ...grpc.CallOption) (*runvv1.PingResponse, error) {
//				panic("mock out the Ping method")
//			},
//			PsFunc: func(ctx context.Context, in *runvv1.RuncPsRequest, opts ...grpc.CallOption) (*runvv1.RuncPsResponse, error) {
//				panic("mock out the Ps method")
//			},
//			ResumeFunc: func(ctx context.Context, in *runvv1.RuncResumeRequest, opts ...grpc.CallOption) (*runvv1.RuncResumeResponse, error) {
//				panic("mock out the Resume method")
//			},
//			RunFunc: func(ctx context.Context, in *runvv1.RuncRunRequest, opts ...grpc.CallOption) (*runvv1.RuncRunResponse, error) {
//				panic("mock out the Run method")
//			},
//			StartFunc: func(ctx context.Context, in *runvv1.RuncStartRequest, opts ...grpc.CallOption) (*runvv1.RuncStartResponse, error) {
//				panic("mock out the Start method")
//			},
//			StateFunc: func(ctx context.Context, in *runvv1.RuncStateRequest, opts ...grpc.CallOption) (*runvv1.RuncStateResponse, error) {
//				panic("mock out the State method")
//			},
//			StatsFunc: func(ctx context.Context, in *runvv1.RuncStatsRequest, opts ...grpc.CallOption) (*runvv1.RuncStatsResponse, error) {
//				panic("mock out the Stats method")
//			},
//			TopFunc: func(ctx context.Context, in *runvv1.RuncTopRequest, opts ...grpc.CallOption) (*runvv1.RuncTopResponse, error) {
//				panic("mock out the Top method")
//			},
//			VersionFunc: func(ctx context.Context, in *runvv1.RuncVersionRequest, opts ...grpc.CallOption) (*runvv1.RuncVersionResponse, error) {
//				panic("mock out the Version method")
//			},
//		}
//
//		// use mockedRuncServiceClient in code that requires runvv1.RuncServiceClient
//		// and then make assertions.
//
//	}
type MockRuncServiceClient struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, in *runvv1.RuncCreateRequest, opts ...grpc.CallOption) (*runvv1.RuncCreateResponse, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, in *runvv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runvv1.RuncDeleteResponse, error)

	// ExecFunc mocks the Exec method.
	ExecFunc func(ctx context.Context, in *runvv1.RuncExecRequest, opts ...grpc.CallOption) (*runvv1.RuncExecResponse, error)

	// KillFunc mocks the Kill method.
	KillFunc func(ctx context.Context, in *runvv1.RuncKillRequest, opts ...grpc.CallOption) (*runvv1.RuncKillResponse, error)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, in *runvv1.RuncListRequest, opts ...grpc.CallOption) (*runvv1.RuncListResponse, error)

	// PauseFunc mocks the Pause method.
	PauseFunc func(ctx context.Context, in *runvv1.RuncPauseRequest, opts ...grpc.CallOption) (*runvv1.RuncPauseResponse, error)

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context, in *runvv1.PingRequest, opts ...grpc.CallOption) (*runvv1.PingResponse, error)

	// PsFunc mocks the Ps method.
	PsFunc func(ctx context.Context, in *runvv1.RuncPsRequest, opts ...grpc.CallOption) (*runvv1.RuncPsResponse, error)

	// ResumeFunc mocks the Resume method.
	ResumeFunc func(ctx context.Context, in *runvv1.RuncResumeRequest, opts ...grpc.CallOption) (*runvv1.RuncResumeResponse, error)

	// RunFunc mocks the Run method.
	RunFunc func(ctx context.Context, in *runvv1.RuncRunRequest, opts ...grpc.CallOption) (*runvv1.RuncRunResponse, error)

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, in *runvv1.RuncStartRequest, opts ...grpc.CallOption) (*runvv1.RuncStartResponse, error)

	// StateFunc mocks the State method.
	StateFunc func(ctx context.Context, in *runvv1.RuncStateRequest, opts ...grpc.CallOption) (*runvv1.RuncStateResponse, error)

	// StatsFunc mocks the Stats method.
	StatsFunc func(ctx context.Context, in *runvv1.RuncStatsRequest, opts ...grpc.CallOption) (*runvv1.RuncStatsResponse, error)

	// TopFunc mocks the Top method.
	TopFunc func(ctx context.Context, in *runvv1.RuncTopRequest, opts ...grpc.CallOption) (*runvv1.RuncTopResponse, error)

	// VersionFunc mocks the Version method.
	VersionFunc func(ctx context.Context, in *runvv1.RuncVersionRequest, opts ...grpc.CallOption) (*runvv1.RuncVersionResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncCreateRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncDeleteRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncExecRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Kill holds details about calls to the Kill method.
		Kill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncKillRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncListRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Pause holds details about calls to the Pause method.
		Pause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncPauseRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.PingRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Ps holds details about calls to the Ps method.
		Ps []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncPsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Resume holds details about calls to the Resume method.
		Resume []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncResumeRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncRunRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncStartRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// State holds details about calls to the State method.
		State []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncStateRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncStatsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Top holds details about calls to the Top method.
		Top []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncTopRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Version holds details about calls to the Version method.
		Version []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runvv1.RuncVersionRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockCreate  sync.RWMutex
	lockDelete  sync.RWMutex
	lockExec    sync.RWMutex
	lockKill    sync.RWMutex
	lockList    sync.RWMutex
	lockPause   sync.RWMutex
	lockPing    sync.RWMutex
	lockPs      sync.RWMutex
	lockResume  sync.RWMutex
	lockRun     sync.RWMutex
	lockStart   sync.RWMutex
	lockState   sync.RWMutex
	lockStats   sync.RWMutex
	lockTop     sync.RWMutex
	lockVersion sync.RWMutex
}

// Create calls CreateFunc.
func (mock *MockRuncServiceClient) Create(ctx context.Context, in *runvv1.RuncCreateRequest, opts ...grpc.CallOption) (*runvv1.RuncCreateResponse, error) {
	if mock.CreateFunc == nil {
		panic("MockRuncServiceClient.CreateFunc: method is nil but RuncServiceClient.Create was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncCreateRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, in, opts...)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedRuncServiceClient.CreateCalls())
func (mock *MockRuncServiceClient) CreateCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncCreateRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncCreateRequest
		Opts []grpc.CallOption
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *MockRuncServiceClient) Delete(ctx context.Context, in *runvv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runvv1.RuncDeleteResponse, error) {
	if mock.DeleteFunc == nil {
		panic("MockRuncServiceClient.DeleteFunc: method is nil but RuncServiceClient.Delete was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncDeleteRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, in, opts...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedRuncServiceClient.DeleteCalls())
func (mock *MockRuncServiceClient) DeleteCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncDeleteRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncDeleteRequest
		Opts []grpc.CallOption
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *MockRuncServiceClient) Exec(ctx context.Context, in *runvv1.RuncExecRequest, opts ...grpc.CallOption) (*runvv1.RuncExecResponse, error) {
	if mock.ExecFunc == nil {
		panic("MockRuncServiceClient.ExecFunc: method is nil but RuncServiceClient.Exec was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncExecRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(ctx, in, opts...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedRuncServiceClient.ExecCalls())
func (mock *MockRuncServiceClient) ExecCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncExecRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncExecRequest
		Opts []grpc.CallOption
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// Kill calls KillFunc.
func (mock *MockRuncServiceClient) Kill(ctx context.Context, in *runvv1.RuncKillRequest, opts ...grpc.CallOption) (*runvv1.RuncKillResponse, error) {
	if mock.KillFunc == nil {
		panic("MockRuncServiceClient.KillFunc: method is nil but RuncServiceClient.Kill was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncKillRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockKill.Lock()
	mock.calls.Kill = append(mock.calls.Kill, callInfo)
	mock.lockKill.Unlock()
	return mock.KillFunc(ctx, in, opts...)
}

// KillCalls gets all the calls that were made to Kill.
// Check the length with:
//
//	len(mockedRuncServiceClient.KillCalls())
func (mock *MockRuncServiceClient) KillCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncKillRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncKillRequest
		Opts []grpc.CallOption
	}
	mock.lockKill.RLock()
	calls = mock.calls.Kill
	mock.lockKill.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *MockRuncServiceClient) List(ctx context.Context, in *runvv1.RuncListRequest, opts ...grpc.CallOption) (*runvv1.RuncListResponse, error) {
	if mock.ListFunc == nil {
		panic("MockRuncServiceClient.ListFunc: method is nil but RuncServiceClient.List was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncListRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, in, opts...)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedRuncServiceClient.ListCalls())
func (mock *MockRuncServiceClient) ListCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncListRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncListRequest
		Opts []grpc.CallOption
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// Pause calls PauseFunc.
func (mock *MockRuncServiceClient) Pause(ctx context.Context, in *runvv1.RuncPauseRequest, opts ...grpc.CallOption) (*runvv1.RuncPauseResponse, error) {
	if mock.PauseFunc == nil {
		panic("MockRuncServiceClient.PauseFunc: method is nil but RuncServiceClient.Pause was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncPauseRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPause.Lock()
	mock.calls.Pause = append(mock.calls.Pause, callInfo)
	mock.lockPause.Unlock()
	return mock.PauseFunc(ctx, in, opts...)
}

// PauseCalls gets all the calls that were made to Pause.
// Check the length with:
//
//	len(mockedRuncServiceClient.PauseCalls())
func (mock *MockRuncServiceClient) PauseCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncPauseRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncPauseRequest
		Opts []grpc.CallOption
	}
	mock.lockPause.RLock()
	calls = mock.calls.Pause
	mock.lockPause.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *MockRuncServiceClient) Ping(ctx context.Context, in *runvv1.PingRequest, opts ...grpc.CallOption) (*runvv1.PingResponse, error) {
	if mock.PingFunc == nil {
		panic("MockRuncServiceClient.PingFunc: method is nil but RuncServiceClient.Ping was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.PingRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx, in, opts...)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedRuncServiceClient.PingCalls())
func (mock *MockRuncServiceClient) PingCalls() []struct {
	Ctx  context.Context
	In   *runvv1.PingRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.PingRequest
		Opts []grpc.CallOption
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// Ps calls PsFunc.
func (mock *MockRuncServiceClient) Ps(ctx context.Context, in *runvv1.RuncPsRequest, opts ...grpc.CallOption) (*runvv1.RuncPsResponse, error) {
	if mock.PsFunc == nil {
		panic("MockRuncServiceClient.PsFunc: method is nil but RuncServiceClient.Ps was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncPsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPs.Lock()
	mock.calls.Ps = append(mock.calls.Ps, callInfo)
	mock.lockPs.Unlock()
	return mock.PsFunc(ctx, in, opts...)
}

// PsCalls gets all the calls that were made to Ps.
// Check the length with:
//
//	len(mockedRuncServiceClient.PsCalls())
func (mock *MockRuncServiceClient) PsCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncPsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncPsRequest
		Opts []grpc.CallOption
	}
	mock.lockPs.RLock()
	calls = mock.calls.Ps
	mock.lockPs.RUnlock()
	return calls
}

// Resume calls ResumeFunc.
func (mock *MockRuncServiceClient) Resume(ctx context.Context, in *runvv1.RuncResumeRequest, opts ...grpc.CallOption) (*runvv1.RuncResumeResponse, error) {
	if mock.ResumeFunc == nil {
		panic("MockRuncServiceClient.ResumeFunc: method is nil but RuncServiceClient.Resume was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncResumeRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockResume.Lock()
	mock.calls.Resume = append(mock.calls.Resume, callInfo)
	mock.lockResume.Unlock()
	return mock.ResumeFunc(ctx, in, opts...)
}

// ResumeCalls gets all the calls that were made to Resume.
// Check the length with:
//
//	len(mockedRuncServiceClient.ResumeCalls())
func (mock *MockRuncServiceClient) ResumeCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncResumeRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncResumeRequest
		Opts []grpc.CallOption
	}
	mock.lockResume.RLock()
	calls = mock.calls.Resume
	mock.lockResume.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *MockRuncServiceClient) Run(ctx context.Context, in *runvv1.RuncRunRequest, opts ...grpc.CallOption) (*runvv1.RuncRunResponse, error) {
	if mock.RunFunc == nil {
		panic("MockRuncServiceClient.RunFunc: method is nil but RuncServiceClient.Run was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncRunRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(ctx, in, opts...)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedRuncServiceClient.RunCalls())
func (mock *MockRuncServiceClient) RunCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncRunRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncRunRequest
		Opts []grpc.CallOption
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *MockRuncServiceClient) Start(ctx context.Context, in *runvv1.RuncStartRequest, opts ...grpc.CallOption) (*runvv1.RuncStartResponse, error) {
	if mock.StartFunc == nil {
		panic("MockRuncServiceClient.StartFunc: method is nil but RuncServiceClient.Start was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncStartRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, in, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedRuncServiceClient.StartCalls())
func (mock *MockRuncServiceClient) StartCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncStartRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncStartRequest
		Opts []grpc.CallOption
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// State calls StateFunc.
func (mock *MockRuncServiceClient) State(ctx context.Context, in *runvv1.RuncStateRequest, opts ...grpc.CallOption) (*runvv1.RuncStateResponse, error) {
	if mock.StateFunc == nil {
		panic("MockRuncServiceClient.StateFunc: method is nil but RuncServiceClient.State was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncStateRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockState.Lock()
	mock.calls.State = append(mock.calls.State, callInfo)
	mock.lockState.Unlock()
	return mock.StateFunc(ctx, in, opts...)
}

// StateCalls gets all the calls that were made to State.
// Check the length with:
//
//	len(mockedRuncServiceClient.StateCalls())
func (mock *MockRuncServiceClient) StateCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncStateRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncStateRequest
		Opts []grpc.CallOption
	}
	mock.lockState.RLock()
	calls = mock.calls.State
	mock.lockState.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *MockRuncServiceClient) Stats(ctx context.Context, in *runvv1.RuncStatsRequest, opts ...grpc.CallOption) (*runvv1.RuncStatsResponse, error) {
	if mock.StatsFunc == nil {
		panic("MockRuncServiceClient.StatsFunc: method is nil but RuncServiceClient.Stats was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncStatsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	return mock.StatsFunc(ctx, in, opts...)
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedRuncServiceClient.StatsCalls())
func (mock *MockRuncServiceClient) StatsCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncStatsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncStatsRequest
		Opts []grpc.CallOption
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// Top calls TopFunc.
func (mock *MockRuncServiceClient) Top(ctx context.Context, in *runvv1.RuncTopRequest, opts ...grpc.CallOption) (*runvv1.RuncTopResponse, error) {
	if mock.TopFunc == nil {
		panic("MockRuncServiceClient.TopFunc: method is nil but RuncServiceClient.Top was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncTopRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockTop.Lock()
	mock.calls.Top = append(mock.calls.Top, callInfo)
	mock.lockTop.Unlock()
	return mock.TopFunc(ctx, in, opts...)
}

// TopCalls gets all the calls that were made to Top.
// Check the length with:
//
//	len(mockedRuncServiceClient.TopCalls())
func (mock *MockRuncServiceClient) TopCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncTopRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncTopRequest
		Opts []grpc.CallOption
	}
	mock.lockTop.RLock()
	calls = mock.calls.Top
	mock.lockTop.RUnlock()
	return calls
}

// Version calls VersionFunc.
func (mock *MockRuncServiceClient) Version(ctx context.Context, in *runvv1.RuncVersionRequest, opts ...grpc.CallOption) (*runvv1.RuncVersionResponse, error) {
	if mock.VersionFunc == nil {
		panic("MockRuncServiceClient.VersionFunc: method is nil but RuncServiceClient.Version was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runvv1.RuncVersionRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockVersion.Lock()
	mock.calls.Version = append(mock.calls.Version, callInfo)
	mock.lockVersion.Unlock()
	return mock.VersionFunc(ctx, in, opts...)
}

// VersionCalls gets all the calls that were made to Version.
// Check the length with:
//
//	len(mockedRuncServiceClient.VersionCalls())
func (mock *MockRuncServiceClient) VersionCalls() []struct {
	Ctx  context.Context
	In   *runvv1.RuncVersionRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runvv1.RuncVersionRequest
		Opts []grpc.CallOption
	}
	mock.lockVersion.RLock()
	calls = mock.calls.Version
	mock.lockVersion.RUnlock()
	return calls
}
