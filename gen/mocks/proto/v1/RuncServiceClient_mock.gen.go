// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockrunmv1

import (
	"context"
	"sync"

	"github.com/walteh/runm/proto/v1"
	"google.golang.org/grpc"
)

// Ensure that MockRuncServiceClient does implement runmv1.RuncServiceClient.
// If this is not the case, regenerate this file with mockery.
var _ runmv1.RuncServiceClient = &MockRuncServiceClient{}

// MockRuncServiceClient is a mock implementation of runmv1.RuncServiceClient.
//
//	func TestSomethingThatUsesRuncServiceClient(t *testing.T) {
//
//		// make and configure a mocked runmv1.RuncServiceClient
//		mockedRuncServiceClient := &MockRuncServiceClient{
//			CheckpointFunc: func(ctx context.Context, in *runmv1.RuncCheckpointRequest, opts ...grpc.CallOption) (*runmv1.RuncCheckpointResponse, error) {
//				panic("mock out the Checkpoint method")
//			},
//			CreateFunc: func(ctx context.Context, in *runmv1.RuncCreateRequest, opts ...grpc.CallOption) (*runmv1.RuncCreateResponse, error) {
//				panic("mock out the Create method")
//			},
//			DeleteFunc: func(ctx context.Context, in *runmv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runmv1.RuncDeleteResponse, error) {
//				panic("mock out the Delete method")
//			},
//			ExecFunc: func(ctx context.Context, in *runmv1.RuncExecRequest, opts ...grpc.CallOption) (*runmv1.RuncExecResponse, error) {
//				panic("mock out the Exec method")
//			},
//			KillFunc: func(ctx context.Context, in *runmv1.RuncKillRequest, opts ...grpc.CallOption) (*runmv1.RuncKillResponse, error) {
//				panic("mock out the Kill method")
//			},
//			NewTempConsoleSocketFunc: func(ctx context.Context, in *runmv1.RuncNewTempConsoleSocketRequest, opts ...grpc.CallOption) (*runmv1.RuncNewTempConsoleSocketResponse, error) {
//				panic("mock out the NewTempConsoleSocket method")
//			},
//			PauseFunc: func(ctx context.Context, in *runmv1.RuncPauseRequest, opts ...grpc.CallOption) (*runmv1.RuncPauseResponse, error) {
//				panic("mock out the Pause method")
//			},
//			PingFunc: func(ctx context.Context, in *runmv1.PingRequest, opts ...grpc.CallOption) (*runmv1.PingResponse, error) {
//				panic("mock out the Ping method")
//			},
//			PsFunc: func(ctx context.Context, in *runmv1.RuncPsRequest, opts ...grpc.CallOption) (*runmv1.RuncPsResponse, error) {
//				panic("mock out the Ps method")
//			},
//			ReadPidFileFunc: func(ctx context.Context, in *runmv1.RuncReadPidFileRequest, opts ...grpc.CallOption) (*runmv1.RuncReadPidFileResponse, error) {
//				panic("mock out the ReadPidFile method")
//			},
//			RestoreFunc: func(ctx context.Context, in *runmv1.RuncRestoreRequest, opts ...grpc.CallOption) (*runmv1.RuncRestoreResponse, error) {
//				panic("mock out the Restore method")
//			},
//			ResumeFunc: func(ctx context.Context, in *runmv1.RuncResumeRequest, opts ...grpc.CallOption) (*runmv1.RuncResumeResponse, error) {
//				panic("mock out the Resume method")
//			},
//			StartFunc: func(ctx context.Context, in *runmv1.RuncStartRequest, opts ...grpc.CallOption) (*runmv1.RuncStartResponse, error) {
//				panic("mock out the Start method")
//			},
//			UpdateFunc: func(ctx context.Context, in *runmv1.RuncUpdateRequest, opts ...grpc.CallOption) (*runmv1.RuncUpdateResponse, error) {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedRuncServiceClient in code that requires runmv1.RuncServiceClient
//		// and then make assertions.
//
//	}
type MockRuncServiceClient struct {
	// CheckpointFunc mocks the Checkpoint method.
	CheckpointFunc func(ctx context.Context, in *runmv1.RuncCheckpointRequest, opts ...grpc.CallOption) (*runmv1.RuncCheckpointResponse, error)

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, in *runmv1.RuncCreateRequest, opts ...grpc.CallOption) (*runmv1.RuncCreateResponse, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, in *runmv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runmv1.RuncDeleteResponse, error)

	// ExecFunc mocks the Exec method.
	ExecFunc func(ctx context.Context, in *runmv1.RuncExecRequest, opts ...grpc.CallOption) (*runmv1.RuncExecResponse, error)

	// KillFunc mocks the Kill method.
	KillFunc func(ctx context.Context, in *runmv1.RuncKillRequest, opts ...grpc.CallOption) (*runmv1.RuncKillResponse, error)

	// NewTempConsoleSocketFunc mocks the NewTempConsoleSocket method.
	NewTempConsoleSocketFunc func(ctx context.Context, in *runmv1.RuncNewTempConsoleSocketRequest, opts ...grpc.CallOption) (*runmv1.RuncNewTempConsoleSocketResponse, error)

	// PauseFunc mocks the Pause method.
	PauseFunc func(ctx context.Context, in *runmv1.RuncPauseRequest, opts ...grpc.CallOption) (*runmv1.RuncPauseResponse, error)

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context, in *runmv1.PingRequest, opts ...grpc.CallOption) (*runmv1.PingResponse, error)

	// PsFunc mocks the Ps method.
	PsFunc func(ctx context.Context, in *runmv1.RuncPsRequest, opts ...grpc.CallOption) (*runmv1.RuncPsResponse, error)

	// ReadPidFileFunc mocks the ReadPidFile method.
	ReadPidFileFunc func(ctx context.Context, in *runmv1.RuncReadPidFileRequest, opts ...grpc.CallOption) (*runmv1.RuncReadPidFileResponse, error)

	// RestoreFunc mocks the Restore method.
	RestoreFunc func(ctx context.Context, in *runmv1.RuncRestoreRequest, opts ...grpc.CallOption) (*runmv1.RuncRestoreResponse, error)

	// ResumeFunc mocks the Resume method.
	ResumeFunc func(ctx context.Context, in *runmv1.RuncResumeRequest, opts ...grpc.CallOption) (*runmv1.RuncResumeResponse, error)

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, in *runmv1.RuncStartRequest, opts ...grpc.CallOption) (*runmv1.RuncStartResponse, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, in *runmv1.RuncUpdateRequest, opts ...grpc.CallOption) (*runmv1.RuncUpdateResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Checkpoint holds details about calls to the Checkpoint method.
		Checkpoint []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncCheckpointRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncCreateRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncDeleteRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncExecRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Kill holds details about calls to the Kill method.
		Kill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncKillRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// NewTempConsoleSocket holds details about calls to the NewTempConsoleSocket method.
		NewTempConsoleSocket []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncNewTempConsoleSocketRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Pause holds details about calls to the Pause method.
		Pause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncPauseRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.PingRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Ps holds details about calls to the Ps method.
		Ps []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncPsRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// ReadPidFile holds details about calls to the ReadPidFile method.
		ReadPidFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncReadPidFileRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Restore holds details about calls to the Restore method.
		Restore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncRestoreRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Resume holds details about calls to the Resume method.
		Resume []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncResumeRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncStartRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *runmv1.RuncUpdateRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockCheckpoint           sync.RWMutex
	lockCreate               sync.RWMutex
	lockDelete               sync.RWMutex
	lockExec                 sync.RWMutex
	lockKill                 sync.RWMutex
	lockNewTempConsoleSocket sync.RWMutex
	lockPause                sync.RWMutex
	lockPing                 sync.RWMutex
	lockPs                   sync.RWMutex
	lockReadPidFile          sync.RWMutex
	lockRestore              sync.RWMutex
	lockResume               sync.RWMutex
	lockStart                sync.RWMutex
	lockUpdate               sync.RWMutex
}

// Checkpoint calls CheckpointFunc.
func (mock *MockRuncServiceClient) Checkpoint(ctx context.Context, in *runmv1.RuncCheckpointRequest, opts ...grpc.CallOption) (*runmv1.RuncCheckpointResponse, error) {
	if mock.CheckpointFunc == nil {
		panic("MockRuncServiceClient.CheckpointFunc: method is nil but RuncServiceClient.Checkpoint was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncCheckpointRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCheckpoint.Lock()
	mock.calls.Checkpoint = append(mock.calls.Checkpoint, callInfo)
	mock.lockCheckpoint.Unlock()
	return mock.CheckpointFunc(ctx, in, opts...)
}

// CheckpointCalls gets all the calls that were made to Checkpoint.
// Check the length with:
//
//	len(mockedRuncServiceClient.CheckpointCalls())
func (mock *MockRuncServiceClient) CheckpointCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncCheckpointRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncCheckpointRequest
		Opts []grpc.CallOption
	}
	mock.lockCheckpoint.RLock()
	calls = mock.calls.Checkpoint
	mock.lockCheckpoint.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *MockRuncServiceClient) Create(ctx context.Context, in *runmv1.RuncCreateRequest, opts ...grpc.CallOption) (*runmv1.RuncCreateResponse, error) {
	if mock.CreateFunc == nil {
		panic("MockRuncServiceClient.CreateFunc: method is nil but RuncServiceClient.Create was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncCreateRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, in, opts...)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedRuncServiceClient.CreateCalls())
func (mock *MockRuncServiceClient) CreateCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncCreateRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncCreateRequest
		Opts []grpc.CallOption
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *MockRuncServiceClient) Delete(ctx context.Context, in *runmv1.RuncDeleteRequest, opts ...grpc.CallOption) (*runmv1.RuncDeleteResponse, error) {
	if mock.DeleteFunc == nil {
		panic("MockRuncServiceClient.DeleteFunc: method is nil but RuncServiceClient.Delete was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncDeleteRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, in, opts...)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedRuncServiceClient.DeleteCalls())
func (mock *MockRuncServiceClient) DeleteCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncDeleteRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncDeleteRequest
		Opts []grpc.CallOption
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *MockRuncServiceClient) Exec(ctx context.Context, in *runmv1.RuncExecRequest, opts ...grpc.CallOption) (*runmv1.RuncExecResponse, error) {
	if mock.ExecFunc == nil {
		panic("MockRuncServiceClient.ExecFunc: method is nil but RuncServiceClient.Exec was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncExecRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(ctx, in, opts...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedRuncServiceClient.ExecCalls())
func (mock *MockRuncServiceClient) ExecCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncExecRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncExecRequest
		Opts []grpc.CallOption
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// Kill calls KillFunc.
func (mock *MockRuncServiceClient) Kill(ctx context.Context, in *runmv1.RuncKillRequest, opts ...grpc.CallOption) (*runmv1.RuncKillResponse, error) {
	if mock.KillFunc == nil {
		panic("MockRuncServiceClient.KillFunc: method is nil but RuncServiceClient.Kill was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncKillRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockKill.Lock()
	mock.calls.Kill = append(mock.calls.Kill, callInfo)
	mock.lockKill.Unlock()
	return mock.KillFunc(ctx, in, opts...)
}

// KillCalls gets all the calls that were made to Kill.
// Check the length with:
//
//	len(mockedRuncServiceClient.KillCalls())
func (mock *MockRuncServiceClient) KillCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncKillRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncKillRequest
		Opts []grpc.CallOption
	}
	mock.lockKill.RLock()
	calls = mock.calls.Kill
	mock.lockKill.RUnlock()
	return calls
}

// NewTempConsoleSocket calls NewTempConsoleSocketFunc.
func (mock *MockRuncServiceClient) NewTempConsoleSocket(ctx context.Context, in *runmv1.RuncNewTempConsoleSocketRequest, opts ...grpc.CallOption) (*runmv1.RuncNewTempConsoleSocketResponse, error) {
	if mock.NewTempConsoleSocketFunc == nil {
		panic("MockRuncServiceClient.NewTempConsoleSocketFunc: method is nil but RuncServiceClient.NewTempConsoleSocket was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncNewTempConsoleSocketRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockNewTempConsoleSocket.Lock()
	mock.calls.NewTempConsoleSocket = append(mock.calls.NewTempConsoleSocket, callInfo)
	mock.lockNewTempConsoleSocket.Unlock()
	return mock.NewTempConsoleSocketFunc(ctx, in, opts...)
}

// NewTempConsoleSocketCalls gets all the calls that were made to NewTempConsoleSocket.
// Check the length with:
//
//	len(mockedRuncServiceClient.NewTempConsoleSocketCalls())
func (mock *MockRuncServiceClient) NewTempConsoleSocketCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncNewTempConsoleSocketRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncNewTempConsoleSocketRequest
		Opts []grpc.CallOption
	}
	mock.lockNewTempConsoleSocket.RLock()
	calls = mock.calls.NewTempConsoleSocket
	mock.lockNewTempConsoleSocket.RUnlock()
	return calls
}

// Pause calls PauseFunc.
func (mock *MockRuncServiceClient) Pause(ctx context.Context, in *runmv1.RuncPauseRequest, opts ...grpc.CallOption) (*runmv1.RuncPauseResponse, error) {
	if mock.PauseFunc == nil {
		panic("MockRuncServiceClient.PauseFunc: method is nil but RuncServiceClient.Pause was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncPauseRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPause.Lock()
	mock.calls.Pause = append(mock.calls.Pause, callInfo)
	mock.lockPause.Unlock()
	return mock.PauseFunc(ctx, in, opts...)
}

// PauseCalls gets all the calls that were made to Pause.
// Check the length with:
//
//	len(mockedRuncServiceClient.PauseCalls())
func (mock *MockRuncServiceClient) PauseCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncPauseRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncPauseRequest
		Opts []grpc.CallOption
	}
	mock.lockPause.RLock()
	calls = mock.calls.Pause
	mock.lockPause.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *MockRuncServiceClient) Ping(ctx context.Context, in *runmv1.PingRequest, opts ...grpc.CallOption) (*runmv1.PingResponse, error) {
	if mock.PingFunc == nil {
		panic("MockRuncServiceClient.PingFunc: method is nil but RuncServiceClient.Ping was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.PingRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx, in, opts...)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedRuncServiceClient.PingCalls())
func (mock *MockRuncServiceClient) PingCalls() []struct {
	Ctx  context.Context
	In   *runmv1.PingRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.PingRequest
		Opts []grpc.CallOption
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// Ps calls PsFunc.
func (mock *MockRuncServiceClient) Ps(ctx context.Context, in *runmv1.RuncPsRequest, opts ...grpc.CallOption) (*runmv1.RuncPsResponse, error) {
	if mock.PsFunc == nil {
		panic("MockRuncServiceClient.PsFunc: method is nil but RuncServiceClient.Ps was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncPsRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockPs.Lock()
	mock.calls.Ps = append(mock.calls.Ps, callInfo)
	mock.lockPs.Unlock()
	return mock.PsFunc(ctx, in, opts...)
}

// PsCalls gets all the calls that were made to Ps.
// Check the length with:
//
//	len(mockedRuncServiceClient.PsCalls())
func (mock *MockRuncServiceClient) PsCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncPsRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncPsRequest
		Opts []grpc.CallOption
	}
	mock.lockPs.RLock()
	calls = mock.calls.Ps
	mock.lockPs.RUnlock()
	return calls
}

// ReadPidFile calls ReadPidFileFunc.
func (mock *MockRuncServiceClient) ReadPidFile(ctx context.Context, in *runmv1.RuncReadPidFileRequest, opts ...grpc.CallOption) (*runmv1.RuncReadPidFileResponse, error) {
	if mock.ReadPidFileFunc == nil {
		panic("MockRuncServiceClient.ReadPidFileFunc: method is nil but RuncServiceClient.ReadPidFile was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncReadPidFileRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockReadPidFile.Lock()
	mock.calls.ReadPidFile = append(mock.calls.ReadPidFile, callInfo)
	mock.lockReadPidFile.Unlock()
	return mock.ReadPidFileFunc(ctx, in, opts...)
}

// ReadPidFileCalls gets all the calls that were made to ReadPidFile.
// Check the length with:
//
//	len(mockedRuncServiceClient.ReadPidFileCalls())
func (mock *MockRuncServiceClient) ReadPidFileCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncReadPidFileRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncReadPidFileRequest
		Opts []grpc.CallOption
	}
	mock.lockReadPidFile.RLock()
	calls = mock.calls.ReadPidFile
	mock.lockReadPidFile.RUnlock()
	return calls
}

// Restore calls RestoreFunc.
func (mock *MockRuncServiceClient) Restore(ctx context.Context, in *runmv1.RuncRestoreRequest, opts ...grpc.CallOption) (*runmv1.RuncRestoreResponse, error) {
	if mock.RestoreFunc == nil {
		panic("MockRuncServiceClient.RestoreFunc: method is nil but RuncServiceClient.Restore was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncRestoreRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockRestore.Lock()
	mock.calls.Restore = append(mock.calls.Restore, callInfo)
	mock.lockRestore.Unlock()
	return mock.RestoreFunc(ctx, in, opts...)
}

// RestoreCalls gets all the calls that were made to Restore.
// Check the length with:
//
//	len(mockedRuncServiceClient.RestoreCalls())
func (mock *MockRuncServiceClient) RestoreCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncRestoreRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncRestoreRequest
		Opts []grpc.CallOption
	}
	mock.lockRestore.RLock()
	calls = mock.calls.Restore
	mock.lockRestore.RUnlock()
	return calls
}

// Resume calls ResumeFunc.
func (mock *MockRuncServiceClient) Resume(ctx context.Context, in *runmv1.RuncResumeRequest, opts ...grpc.CallOption) (*runmv1.RuncResumeResponse, error) {
	if mock.ResumeFunc == nil {
		panic("MockRuncServiceClient.ResumeFunc: method is nil but RuncServiceClient.Resume was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncResumeRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockResume.Lock()
	mock.calls.Resume = append(mock.calls.Resume, callInfo)
	mock.lockResume.Unlock()
	return mock.ResumeFunc(ctx, in, opts...)
}

// ResumeCalls gets all the calls that were made to Resume.
// Check the length with:
//
//	len(mockedRuncServiceClient.ResumeCalls())
func (mock *MockRuncServiceClient) ResumeCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncResumeRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncResumeRequest
		Opts []grpc.CallOption
	}
	mock.lockResume.RLock()
	calls = mock.calls.Resume
	mock.lockResume.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *MockRuncServiceClient) Start(ctx context.Context, in *runmv1.RuncStartRequest, opts ...grpc.CallOption) (*runmv1.RuncStartResponse, error) {
	if mock.StartFunc == nil {
		panic("MockRuncServiceClient.StartFunc: method is nil but RuncServiceClient.Start was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncStartRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, in, opts...)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedRuncServiceClient.StartCalls())
func (mock *MockRuncServiceClient) StartCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncStartRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncStartRequest
		Opts []grpc.CallOption
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *MockRuncServiceClient) Update(ctx context.Context, in *runmv1.RuncUpdateRequest, opts ...grpc.CallOption) (*runmv1.RuncUpdateResponse, error) {
	if mock.UpdateFunc == nil {
		panic("MockRuncServiceClient.UpdateFunc: method is nil but RuncServiceClient.Update was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *runmv1.RuncUpdateRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, in, opts...)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedRuncServiceClient.UpdateCalls())
func (mock *MockRuncServiceClient) UpdateCalls() []struct {
	Ctx  context.Context
	In   *runmv1.RuncUpdateRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *runmv1.RuncUpdateRequest
		Opts []grpc.CallOption
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
