// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer

package mockvmmv1

import (
	"context"
	"sync"

	"github.com/walteh/runm/proto/vmm/v1"
)

// Ensure that MockHostCallbackServiceServer does implement vmmv1.HostCallbackServiceServer.
// If this is not the case, regenerate this file with mockery.
var _ vmmv1.HostCallbackServiceServer = &MockHostCallbackServiceServer{}

// MockHostCallbackServiceServer is a mock implementation of vmmv1.HostCallbackServiceServer.
//
//	func TestSomethingThatUsesHostCallbackServiceServer(t *testing.T) {
//
//		// make and configure a mocked vmmv1.HostCallbackServiceServer
//		mockedHostCallbackServiceServer := &MockHostCallbackServiceServer{
//			ForkExecProxyFunc: func(context1 context.Context, forkExecProxyRequest *vmmv1.ForkExecProxyRequest) (*vmmv1.ForkExecProxyResponse, error) {
//				panic("mock out the ForkExecProxy method")
//			},
//		}
//
//		// use mockedHostCallbackServiceServer in code that requires vmmv1.HostCallbackServiceServer
//		// and then make assertions.
//
//	}
type MockHostCallbackServiceServer struct {
	// ForkExecProxyFunc mocks the ForkExecProxy method.
	ForkExecProxyFunc func(context1 context.Context, forkExecProxyRequest *vmmv1.ForkExecProxyRequest) (*vmmv1.ForkExecProxyResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// ForkExecProxy holds details about calls to the ForkExecProxy method.
		ForkExecProxy []struct {
			// Context1 is the context1 argument value.
			Context1 context.Context
			// ForkExecProxyRequest is the forkExecProxyRequest argument value.
			ForkExecProxyRequest *vmmv1.ForkExecProxyRequest
		}
	}
	lockForkExecProxy sync.RWMutex
}

// ForkExecProxy calls ForkExecProxyFunc.
func (mock *MockHostCallbackServiceServer) ForkExecProxy(context1 context.Context, forkExecProxyRequest *vmmv1.ForkExecProxyRequest) (*vmmv1.ForkExecProxyResponse, error) {
	if mock.ForkExecProxyFunc == nil {
		panic("MockHostCallbackServiceServer.ForkExecProxyFunc: method is nil but HostCallbackServiceServer.ForkExecProxy was just called")
	}
	callInfo := struct {
		Context1             context.Context
		ForkExecProxyRequest *vmmv1.ForkExecProxyRequest
	}{
		Context1:             context1,
		ForkExecProxyRequest: forkExecProxyRequest,
	}
	mock.lockForkExecProxy.Lock()
	mock.calls.ForkExecProxy = append(mock.calls.ForkExecProxy, callInfo)
	mock.lockForkExecProxy.Unlock()
	return mock.ForkExecProxyFunc(context1, forkExecProxyRequest)
}

// ForkExecProxyCalls gets all the calls that were made to ForkExecProxy.
// Check the length with:
//
//	len(mockedHostCallbackServiceServer.ForkExecProxyCalls())
func (mock *MockHostCallbackServiceServer) ForkExecProxyCalls() []struct {
	Context1             context.Context
	ForkExecProxyRequest *vmmv1.ForkExecProxyRequest
} {
	var calls []struct {
		Context1             context.Context
		ForkExecProxyRequest *vmmv1.ForkExecProxyRequest
	}
	mock.lockForkExecProxy.RLock()
	calls = mock.calls.ForkExecProxy
	mock.lockForkExecProxy.RUnlock()
	return calls
}
