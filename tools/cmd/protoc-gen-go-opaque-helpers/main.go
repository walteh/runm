package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var flags flag.FlagSet
	enableProtovalidate := flags.Bool("enable_protovalidate", false, "generate protovalidate helpers")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL | pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
		gen.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_2023
		gen.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2024

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			if err := generateFile(gen, f, *enableProtovalidate); err != nil {
				return fmt.Errorf("failed to generate file %s: %w", f.Desc.Path(), err)
			}
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File, enableValidation bool) error {
	if len(file.Messages) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_opaque_helpers.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	generateFileHeader(g, file)

	var hasValidationHelpers bool

	// Process all messages recursively (including nested ones)
	var processMessages func([]*protogen.Message)
	processMessages = func(messages []*protogen.Message) {
		for _, message := range messages {
			if shouldGenerateHelpers(message) {
				generateMessageHelpers(g, message, enableValidation)
				generateOneofHelpers(g, message, enableValidation)
				if enableValidation {
					hasValidationHelpers = true
				}
			}
			// Recursively process nested messages
			processMessages(message.Messages)
		}
	}

	processMessages(file.Messages)

	if hasValidationHelpers {
		g.QualifiedGoIdent(protogen.GoIdent{
			GoName:       "Validate",
			GoImportPath: "buf.build/go/protovalidate",
		})
	}

	return nil
}

func generateFileHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-go-opaque-helpers. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate ptr helper function
	g.P("// ptr is a helper function to get a pointer to a value")
	g.P("func ptr[T any](v T) *T { return &v }")
	g.P()
}

func shouldGenerateHelpers(message *protogen.Message) bool {
	// Skip nested types (map entries, oneof wrappers)
	if message.Desc.IsMapEntry() {
		return false
	}

	// Skip messages that are oneofs (ending with underscore)
	if strings.HasSuffix(string(message.Desc.Name()), "_") {
		return false
	}

	// Generate helpers for both top-level messages and nested messages
	// (like ExecRequest_Start, ExecResponse_Exit, etc.)
	// In edition 2023/2024 with opaque API, all non-map, non-oneof messages have builders
	return true
}

func generateMessageHelpers(g *protogen.GeneratedFile, message *protogen.Message, enableValidation bool) {
	messageName := message.GoIdent.GoName
	builderName := messageName + "_builder"

	// Generate New helper (direct creation, no error)
	g.P("// New", messageName, " creates a new ", messageName, " using the builder pattern")
	g.P("func New", messageName, "(f func(*", builderName, ")) *", messageName, " {")
	g.P("	b := &", builderName, "{}")
	g.P("	f(b)")
	g.P("	return b.Build()")
	g.P("}")
	g.P()

	// Always generate the "E" version - with validation if enabled, without if disabled
	if enableValidation {
		validateIdent := g.QualifiedGoIdent(protogen.GoIdent{
			GoName:       "Validate",
			GoImportPath: "buf.build/go/protovalidate",
		})

		g.P("// New", messageName, "E creates a new ", messageName, " using the builder pattern with validation")
		g.P("func New", messageName, "E(f func(*", builderName, ")) (*", messageName, ", error) {")
		g.P("	m := New", messageName, "(f)")
		g.P("	if err := ", validateIdent, "(m); err != nil {")
		g.P("		return nil, err")
		g.P("	}")
		g.P("	return m, nil")
		g.P("}")
		g.P()
	} else {
		g.P("// New", messageName, "E creates a new ", messageName, " using the builder pattern (validation disabled)")
		g.P("func New", messageName, "E(f func(*", builderName, ")) (*", messageName, ", error) {")
		g.P("	m := New", messageName, "(f)")
		g.P("	return m, nil")
		g.P("}")
		g.P()
	}
}

func generateOneofHelpers(g *protogen.GeneratedFile, message *protogen.Message, enableValidation bool) {
	messageName := message.GoIdent.GoName
	builderName := messageName + "_builder"

	// Iterate through all fields to find oneof fields
	for _, field := range message.Fields {
		if field.Oneof == nil {
			continue // Skip non-oneof fields
		}

		// Get the field type for the oneof
		fieldName := field.GoName
		var fieldTypeName string
		var fieldBuilderName string

		// Determine the type name and builder name based on the field type
		if field.Message != nil {
			// Field is a message type
			fieldTypeName = field.Message.GoIdent.GoName
			fieldBuilderName = fieldTypeName + "_builder"
		} else {
			// Field is a scalar type - skip for now as they don't have builders
			continue
		}

		// Generate combined helper: NewMessage_WithField
		funcName := "New" + messageName + "_With" + fieldName
		g.P("// ", funcName, " creates a new ", messageName, " with the ", fieldName, " field set using the builder pattern")
		g.P("func ", funcName, "(f func(*", fieldBuilderName, ")) *", messageName, " {")
		g.P("	inner := New", fieldTypeName, "(f)")
		g.P("	return New", messageName, "(func(b *", builderName, ") {")
		g.P("		b.", fieldName, " = inner")
		g.P("	})")
		g.P("}")
		g.P()

		// Always generate "E" version - with validation if enabled, without if disabled
		validatedFuncNameE := "New" + messageName + "_With" + fieldName + "E"
		if enableValidation {
			validateIdent := g.QualifiedGoIdent(protogen.GoIdent{
				GoName:       "Validate",
				GoImportPath: "buf.build/go/protovalidate",
			})

			g.P("// ", validatedFuncNameE, " creates a new ", messageName, " with the ", fieldName, " field set using the builder pattern with validation")
			g.P("func ", validatedFuncNameE, "(f func(*", fieldBuilderName, ")) (*", messageName, ", error) {")
			g.P("	inner, err := New", fieldTypeName, "E(f)")
			g.P("	if err != nil {")
			g.P("		return nil, err")
			g.P("	}")
			g.P("	m := New", messageName, "(func(b *", builderName, ") {")
			g.P("		b.", fieldName, " = inner")
			g.P("	})")
			g.P("	if err := ", validateIdent, "(m); err != nil {")
			g.P("		return nil, err")
			g.P("	}")
			g.P("	return m, nil")
			g.P("}")
			g.P()
		} else {
			g.P("// ", validatedFuncNameE, " creates a new ", messageName, " with the ", fieldName, " field set using the builder pattern (validation disabled)")
			g.P("func ", validatedFuncNameE, "(f func(*", fieldBuilderName, ")) (*", messageName, ", error) {")
			g.P("	inner := New", fieldTypeName, "(f)")
			g.P("	m := New", messageName, "(func(b *", builderName, ") {")
			g.P("		b.", fieldName, " = inner")
			g.P("	})")
			g.P("	return m, nil")
			g.P("}")
			g.P()
		}
	}
}
